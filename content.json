{"meta":{"title":"Aier02","subtitle":null,"description":null,"author":"易安明","url":"http://aier02.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-08-06T10:41:28.220Z","updated":"2018-08-04T16:46:32.021Z","comments":false,"path":"/404.html","permalink":"http://aier02.com//404.html","excerpt":"","text":""},{"title":"书单","date":"2018-08-05T02:38:10.217Z","updated":"2018-08-04T16:46:32.022Z","comments":false,"path":"books/index.html","permalink":"http://aier02.com/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-08-06T10:42:02.162Z","updated":"2018-08-04T16:46:32.022Z","comments":false,"path":"about/index.html","permalink":"http://aier02.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2018-08-05T02:38:10.227Z","updated":"2018-08-04T16:46:32.022Z","comments":false,"path":"categories/index.html","permalink":"http://aier02.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-05T02:38:10.236Z","updated":"2018-08-04T16:46:32.023Z","comments":false,"path":"tags/index.html","permalink":"http://aier02.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-08-05T02:19:10.292Z","updated":"2018-08-04T16:46:32.023Z","comments":false,"path":"repository/index.html","permalink":"http://aier02.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-08-05T02:19:59.559Z","updated":"2018-08-04T16:46:32.023Z","comments":true,"path":"links/index.html","permalink":"http://aier02.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"inception","slug":"inception","date":"2019-01-15T08:23:32.427Z","updated":"2019-01-15T09:03:57.369Z","comments":true,"path":"2019/01/15/inception/","link":"","permalink":"http://aier02.com/2019/01/15/inception/","excerpt":"","text":"Inception 网络是 CNN 分类器发展史上一个重要的里程碑。在 Inception 出现之前，大部分流行 CNN 仅仅是把卷积层堆叠得越来越多，使网络越来越深，以此希望能够得到更好的性能。GoogLeNet 最大的特点就是使用了 Inception 模块，它的目的是设计一种具有优良局部拓扑结构的网络，即对输入图像并行地执行多个卷积运算或池化操作，并将所有输出结果拼接为一个非常深的特征图。因为 1x1,3x3 或 5x5 等不同的卷积运算与池化操作可以获得输入图像的不同信息，并行处理这些运算并结合所有结果将获得更好的图像表征 Inception v1问题：图像中突出部分的大小差别很大。例如，狗的图像可以是以下任意情况。每张图像中狗所占区域都是不同的，占据全图，图的中间部分，图的上方小部分。同一数据集中由于信息位置的差异巨大，为卷积操作选择的合适大小的卷积核也更加困难；信息分布更全局性的图像偏好大的卷积核，信息分布比较局部的图像偏好于小的卷积核。非常深的网络更容易过拟合，将梯度更新传输到整个网络十分困难。简单的堆叠较大的卷积层非常消耗计算资源解决方法：拓宽网络层的宽度而不是深度下图是「原始」Inception 模块。它使用 3 个不同大小的滤波器（1x1、3x3、5x5）对输入执行卷积操作，此外它还会执行最大池化。所有子层的输出最后会被级联起来，并传送至下一个 Inception 模块。为了降低算力成本，作者在 3x3 和 5x5 卷积层之前添加额外的 1x1 卷积层，来限制输入信道的数量。尽管添加额外的卷积操作似乎是反直觉的，但是 1x1 卷积比 5x5 卷积要廉价很多，而且输入信道数量减少也有利于降低算力成本。不过一定要注意，1x1 卷积是在最大池化层之后，而不是之前。 Inception v2问题：减少特征的表征性瓶颈。直观上来说，当卷积不会大幅度改变输入维度时，神经网络可能会执行地更好。过多地减少维度可能会造成信息的损失，这也称为「表征性瓶颈」。使用更优秀的因子分解方法，卷积才能在计算复杂度上更加高效。解决方案：将 5×5 的卷积分解为两个 3×3 的卷积运算以提升计算速度。尽管这有点违反直觉，但一个 5×5 的卷积在计算成本上是一个 3×3 卷积的 2.78 倍。所以叠加两个 3×3 卷积实际上在性能上会有所提升，如下图所示将 nxn 的卷积核尺寸分解为 1×n 和 n×1 两个卷积。例如，一个 3×3 的卷积等价于首先执行一个 1×3 的卷积再执行一个 3×1 的卷积。他们还发现这种方法在成本上要比单个 3×3 的卷积降低 33%.模块中的滤波器组被扩展（即变得更宽而不是更深），以解决表征性瓶颈。如果该模块没有被拓展宽度，而是变得更深，那么维度会过多减少，造成信息损失.","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://aier02.com/tags/blog/"}]},{"title":"BoW in cv","slug":"BoW_in_cv","date":"2019-01-12T02:59:03.404Z","updated":"2019-01-12T02:59:23.356Z","comments":true,"path":"2019/01/12/BoW_in_cv/","link":"","permalink":"http://aier02.com/2019/01/12/BoW_in_cv/","excerpt":"","text":"Bag of words词袋模型可以理解为直方图统计，都是对目标的频率统计，而没有序列信息；但和histogram不同的是，histogram统计的的是某个区间的频率，词袋模型统计的是words字典中每个单词出现的次数。比如现有两个文档12John likes to watch movies. Mary likes too.John also likes to watch football games.找出两个文档的并集，构建dictionary1&#123;\"John\":1, 'likes':2, \"to\":3, 'watch':4, 'movies':5, 'also':6, 'football':7, 'games':8, 'Mary':9, 'too':10&#125;则这两篇文档得到的BoW(刚开始用于自然语言处理和信息检索中的一种文档表示方法)12[1,2,1,1,1,0,0,0,1,1][1,1,1,1,0,1,1,1,0,0] BoW model in CV先提取图像集中的特征集合，然后使用聚类的方法得到若干类，利用这些类构建dictionary，相当于words，最后每个图像统计字典中word出现的频数作为输出向量，用于后续的检索、分类等操作。下图以提取图像的sift特征为例；SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换，由加拿大教授David G.Lowe提出的。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。之后在每一幅图像中统计sift特征点在dictionary上的频数分布，得到的向量就是该图像的BoW向量下图是图像集中包含人脸、自行车、吉他等。可以理解为每张图都是一个‘词袋’，包含了不同种类的数量不同的特征，然后统计该图中不同‘单词’的频数。","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://aier02.com/tags/blog/"}]},{"title":"gradient vanishing & exploding problem","slug":"gradient-vanishing-&-exploding-problem","date":"2019-01-11T07:33:27.121Z","updated":"2019-01-11T07:33:27.121Z","comments":true,"path":"2019/01/11/gradient-vanishing-&-exploding-problem/","link":"","permalink":"http://aier02.com/2019/01/11/gradient-vanishing-&-exploding-problem/","excerpt":"","text":"在面senetime的时候由resnet为何能解决随着网络加深而不再导致准确率下降的问题引出了梯度的问题，发现自己的对梯度消失和梯度爆炸问题认识非常有限，仅局限于激活函数的影响，也就是cs231n介绍激活函数的时候所介绍的饱和问题，但是显然若使用Relu函数不存在这种问题，并且resnet的巧妙之处也不是激活函数的创新；这里在查找了一些blog后进行个人的总结。","categories":[{"name":"dl","slug":"dl","permalink":"http://aier02.com/categories/dl/"}],"tags":[{"name":"gradient","slug":"gradient","permalink":"http://aier02.com/tags/gradient/"}]},{"title":"LSTMs","slug":"LSTMs","date":"2019-01-11T07:33:13.044Z","updated":"2019-01-11T08:59:06.676Z","comments":true,"path":"2019/01/11/LSTMs/","link":"","permalink":"http://aier02.com/2019/01/11/LSTMs/","excerpt":"","text":"毕设任务暂定为video classification，一种实现方式使用到了LSTM神经网络，先做简单的入门准备。 Recurrent Neural NetworksRNN(循环神经网络)的提出是传统的CNN难以应对tmporal context的情况下提出的，他的目的就是针对时许关系，把上一个时间的网络输出联合当前时间的输入作为新的当前时间的输入，以实现利用上个时间的信息。未展开的RNN结构展开的RNN结构一般RNN的问题在于伴随着gap的变大，网络的输出与之前的较久的输出的关系不断减弱，使得后面的网络无法学习到较早的知识，即存在长时间的依赖问题。 LSTM NetworksLong Short Term Memory networks的提出就是针对普通RNN固有的记忆时间短的问题，是一种特殊的RNN，善于解决长时间依赖问题，LSTM默认的行为时记住长时间的信息，所有的RNN都具有重复nn的链式结构标准RNN的链式结构LSTM的链式结构上图各种标示的意义黄色的矩形表示用于学习的神经网络，粉色的原点表示逐点的运算，横箭头表示向量的操作，两条线的合箭头表示串联，分箭头表示复制了该向量，并分别用于不同的部分。 The Core Idea Behind LSTMsLSTM中的关键时cell state，下图中顶部的水平线即为cell state的传送路径，用于信息传送,他能直接贯通整个LSTM；LSTM中用gate实现对cell state的信息移除或者添加，gate是一条有选择性的信息通路，它由sigmoid神经网络层和一个逐点乘法运算组成。通过sigmoid决定要通过的程度，与cell state相乘得到想要控制通过的cell state部分s型曲线的输出为[0,1]，0表示全部信息都不通过，相反1为全部信息通过。一个LSTM中有3个这样的gate，用于控制和保护cell state. Step-by-Step LSTM Walk ThroughLSTM中的第一步是决定哪些信息需要从cell state中移除，利用sigmoid layer实现这一操作，即通过‘forget gate layer’，控制信息是否通过，利用ht−1h_{t-1}h​t−1​​和xtx_tx​t​​的信息输出0到1，0表示全部‘忘记’，1表示‘记住’上一次全部的cell state.2.第二步是要决定哪些新的信息需要保存在cell state中，包括两个部分：input gate layer：一个sigmoid layer，决定了需要更新哪些值。Tanh layer:创建新的候选cell state向量3.第三步综合之前两步决定要遗忘的信息和要更新的信息，更新本次的cell state，新的cell state由两部分组成：ft∗ct−1f_t*c_{t-1}f​t​​∗c​t−1​​上一次的cell state 乘以遗忘系数得到目前需要的旧cell state 的信息程度。it∗ct‾i_t*\\overline{c_t}i​t​​∗​c​t​​​​​要更新的信息值对应的index乘以候选的cell state得到本次要更新后的候选cell state4.最后决定输出，先通过一个sigmoid layer决定cell state哪些部分需要输出(该操作和第三步的决定cell state哪些部分需要更新的操作一致)，同时将之前3步算出来的cell state通过tanh layer(压缩输出到[-1,1])，然后tanh layer 得到的值和sigmoid layer 得到的值进行相乘，得到最后要输出的部分。 Variants on Long Short Term Memory上述为正常的LSTM结构，但是在不同情况下可能存在不同LSTM，下面分别描述不同的变体。1.gate layer也关注cell state,即cell state也作为所有gate的输入，术语上说是给gate layer添加一个peephole2.直接使用成对的forget gate 和 input gate，同时决定遗忘的部分和更新的部分；而不是分别去决定哪些需要忘记和哪些需要添加。比较特别的变体是Gated Recurrent Unit，将forget gate和input gate合并为了一个update gate,同时合并了cell state 和hidden state","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://aier02.com/tags/blog/"}]},{"title":"epoch & iteration","slug":"epoch & iteration","date":"2019-01-10T11:15:52.935Z","updated":"2019-01-11T05:16:34.023Z","comments":true,"path":"2019/01/10/epoch & iteration/","link":"","permalink":"http://aier02.com/2019/01/10/epoch & iteration/","excerpt":"","text":"再使用pytorch进行训练时，经常会看到batch_size,iteration,step,epoch这几个词，他们的意思和关系分别如下：epoch:一个epoch表示所有训练的样本运算学习一遍iteration/step：表示每运行一个iteration/step，更新一次参数权重，即进行一次学习，每进行一次更新都需要batch_size个样本进行运算学习，根据运算的结果更新一次参数；对应训练时为一张卡一个进程读取了batch_size张图片，froward/backward一次后，学习了一次参数，计作一次stepbatch_size：一次参数更新运算所需的样本数量，即一张卡中读取的sample数量在多卡多机训练时，每进行一次step后，都要重新加载数据，即使用train_loader重新读取一个batch到GPU上。","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://aier02.com/tags/pytorch/"}]},{"title":"BN","slug":"BN","date":"2019-01-09T11:45:40.264Z","updated":"2019-01-09T11:45:41.115Z","comments":true,"path":"2019/01/09/BN/","link":"","permalink":"http://aier02.com/2019/01/09/BN/","excerpt":"","text":"L2正则化通常对稀疏的有尖峰的权重响亮施加比较大的惩罚，而偏向于均匀的参数，这样做的效果时鼓励神经但愿利用上层的所有输入，而不是部分输入，所以L2正则项加入之后，权重的绝对值大小都会整体倾向于减少，尤其不会出现特别大的值，即网络偏向于学习比较小的权重，所以L2正则化在深度学习中又叫做‘权重衰减’(weight decay),在机器学习中又叫做‘岭回归’(rifge regression)BN的第四步做的尺度变换和偏移，由于归一化后xix_ix​i​​基本被限制在了正态分布下，使得网络的表达能力下降，引入两个参数，使得网络在训练时自己进行学习。数据被压缩到中心区域，对于大多数激活函数而言，中间区域的梯度都是最大的或者说是有梯度的，是变化敏感区域，这样可以加快收敛速度。在训练时，对同一批次的数据均值和方差进行求解，进而进行归一化操作；而在预测的时候，所使用的均值和方差来源于训练集，比如在训练时，我们记录下每个batch的均值和方差，待训练完毕后，求整个训练样本的均值和方差的期望，作为预测时进行BN的均值和方差。测试阶段使用的BN公式为：关于BN层使用的位置，在CNN中一般是作用于激活函数之前。若遇到梯度爆炸或者收敛速度很慢时可以考虑使用BN。","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"regularization","slug":"regularization","permalink":"http://aier02.com/tags/regularization/"}]},{"title":"pytorch argparser","slug":"pytorch_argparser","date":"2019-01-07T07:27:16.595Z","updated":"2019-01-10T11:12:26.691Z","comments":true,"path":"2019/01/07/pytorch_argparser/","link":"","permalink":"http://aier02.com/2019/01/07/pytorch_argparser/","excerpt":"","text":"argparse 是在pytorch中用于解析命令行参数和选项的标准模块，在编写main脚本时，常常有很多路径、选项等参数需要确定，为了提高代码的健壮性，需要提高命令选项用于修改main中的参数，而不至于为了修改参数而要打开源代码进行。 一般步骤import argparse 引用模块parser=argparse.ArgumentParser(description=‘介绍该解释器’) 创建一个parser对象parser.add_argument() 向解析器对象添加要关注的命令行参数和选项，一个add对应一个参数parser.parse_args() 调用parse_args方法进行解析，即可使用###add_argument(name or flags…[, action][nargs],[ const],[ default],[ type], choices],[ required],[help],[ metavar],[dest])其中：name or flags：命令行参数名或者选项，如上面的address或者-p,–port.其中命令行参数如果没给定，且没有设置defualt，则出错。但是如果是选项的话，则设置为Noneaction:action=‘store_true’,表示若出现name命令参数，则设置该参数为True，若无出现，则默认为False，反之action=“store_false”，表示若出现则设置为False,否则默认为True.nargs：命令行参数的个数，一般使用通配符表示，其中，’?‘表示只用一个，’*‘表示0到多个，’+'表示至少一个default：默认值type：参数的类型，默认是字符串string类型，还有float、int等类型help：和ArgumentParser方法中的参数作用相似，出现的场合也一致 注意args=parser.parse_args()时，比如parser.add_argument(’–load-path’,default=’’,type=str),则运行了python命令–load-path='example_file’后，在py文件中读取该参数时是通过args.load_path，注意不是load-path，模块已经把中间的-换成了下滑线。","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://aier02.com/categories/pytorch/"}],"tags":[{"name":"sensetime","slug":"sensetime","permalink":"http://aier02.com/tags/sensetime/"},{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://aier02.com/tags/basic-knowledge/"}]},{"title":"label smoothing","slug":"label-smoothing","date":"2019-01-07T03:44:48.760Z","updated":"2019-01-07T03:44:48.760Z","comments":true,"path":"2019/01/07/label-smoothing/","link":"","permalink":"http://aier02.com/2019/01/07/label-smoothing/","excerpt":"","text":"由于训练的样本通常会存在小量的错误标签，这些错误的标签会影响预测的结果，为了减少模型对训练集的依赖，增强模型的泛化能力，采用标签平滑的思路进行解决：在训练时假设标签可能存在错误，避免过分地相信模型的标签，“告诉”模型样本的标签不一定正确，则训练出来的模型对于少量的样本错误就有“免疫力”。在二分类任务中，训练样本为(xi,yix_i,y_ix​i​​,y​i​​),yiy_iy​i​​为样本标签，即0或者1，而在训练中每次迭代时，并不直接将(xi,yi)(x_i,y_i)(x​i​​,y​i​​)放入训练中集中，而是设置一个错误率ϵ\\epsilonϵ,以1−ϵ1-\\epsilon1−ϵ的概率将样本直接代入，以ϵ\\epsilonϵ的概率代入(xi,1−yi)(x_i,1-y_i)(x​i​​,1−y​i​​)，则模型在训练时，既有正确的标签输入，又有错误的标签输入，这样训练出来的模型不会“全力匹配”每一个标签，而只是在一定程度上匹配，因此出现错误标签时，模型受到的影响就会降低。当采用交叉熵来描述损失函数时，对于每一个样本而言，标签变换成了yi={ϵ,yi=01−ϵ,yi=1y_i = \\begin{cases} \\epsilon, &amp; y_i=0\\\\ 1-\\epsilon, &amp; y_i = 1 \\end{cases}y​i​​={​ϵ,​1−ϵ,​​​y​i​​=0​y​i​​=1​​即当标签为0时，不把0直接代入训练，而是替换成一个较小的数ϵ\\epsilonϵ,同理，当标签为1时，替换成1−ϵ1-\\epsilon1−ϵ。所谓平滑即两个极端的值0和1替换成不那么极端的值；在多分类任务中，仍然假设标签值在一定概率下不变，以一定概率变为其他值，若假设均匀分布，则把所有的标签1变为1−ϵ1-\\epsilon1−ϵ，所有的标签0变为ϵk−1\\frac \\epsilon {k-1}​k−1​​ϵ​​.","categories":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/categories/cv/"}],"tags":[{"name":"regularization","slug":"regularization","permalink":"http://aier02.com/tags/regularization/"},{"name":"sensetime","slug":"sensetime","permalink":"http://aier02.com/tags/sensetime/"}]},{"title":"independent component analysis","slug":"independent_component","date":"2018-12-16T12:42:23.350Z","updated":"2018-12-16T14:59:53.745Z","comments":true,"path":"2018/12/16/independent_component/","link":"","permalink":"http://aier02.com/2018/12/16/independent_component/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"singular value decomposition","slug":"singular_value_decomposit","date":"2018-12-16T12:41:34.425Z","updated":"2018-12-16T15:00:01.717Z","comments":true,"path":"2018/12/16/singular_value_decomposit/","link":"","permalink":"http://aier02.com/2018/12/16/singular_value_decomposit/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"principal component analysis","slug":"principal_component","date":"2018-12-16T12:40:51.673Z","updated":"2018-12-16T15:00:11.897Z","comments":true,"path":"2018/12/16/principal_component/","link":"","permalink":"http://aier02.com/2018/12/16/principal_component/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"mixture of Gaussian","slug":"mixture_of_Gau","date":"2018-12-16T12:39:57.674Z","updated":"2018-12-16T15:00:20.365Z","comments":true,"path":"2018/12/16/mixture_of_Gau/","link":"","permalink":"http://aier02.com/2018/12/16/mixture_of_Gau/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"exception maximization","slug":"exception_maximization","date":"2018-12-16T12:39:07.498Z","updated":"2018-12-16T15:03:43.711Z","comments":true,"path":"2018/12/16/exception_maximization/","link":"","permalink":"http://aier02.com/2018/12/16/exception_maximization/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"bayesian statistic","slug":"bayesian_statist","date":"2018-12-16T12:37:36.576Z","updated":"2018-12-16T15:00:54.868Z","comments":true,"path":"2018/12/16/bayesian_statist/","link":"","permalink":"http://aier02.com/2018/12/16/bayesian_statist/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"feature selection","slug":"feature_selection","date":"2018-12-16T12:36:22.956Z","updated":"2018-12-16T15:01:29.782Z","comments":true,"path":"2018/12/16/feature_selection/","link":"","permalink":"http://aier02.com/2018/12/16/feature_selection/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"empirial risk minimization","slug":"empirial_risk_minimize","date":"2018-12-16T12:35:49.024Z","updated":"2018-12-16T15:02:02.606Z","comments":true,"path":"2018/12/16/empirial_risk_minimize/","link":"","permalink":"http://aier02.com/2018/12/16/empirial_risk_minimize/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"kernel method","slug":"kernel_method","date":"2018-12-16T12:34:21.064Z","updated":"2018-12-16T15:05:13.356Z","comments":true,"path":"2018/12/16/kernel_method/","link":"","permalink":"http://aier02.com/2018/12/16/kernel_method/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"Lagrange multiplian","slug":"Lagrange_multiplian","date":"2018-12-16T12:32:02.432Z","updated":"2018-12-16T15:05:31.241Z","comments":true,"path":"2018/12/16/Lagrange_multiplian/","link":"","permalink":"http://aier02.com/2018/12/16/Lagrange_multiplian/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"naive Bayes","slug":"naive_Bayse","date":"2018-12-16T12:29:24.745Z","updated":"2018-12-16T15:06:47.058Z","comments":true,"path":"2018/12/16/naive_Bayse/","link":"","permalink":"http://aier02.com/2018/12/16/naive_Bayse/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"generative learning algorithms","slug":"generative_learning_algorithms","date":"2018-12-16T12:27:05.959Z","updated":"2018-12-16T12:27:49.137Z","comments":true,"path":"2018/12/16/generative_learning_algorithms/","link":"","permalink":"http://aier02.com/2018/12/16/generative_learning_algorithms/","excerpt":"","text":"","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"logistic regression","slug":"logistic_regression","date":"2018-12-16T11:54:52.916Z","updated":"2018-12-16T12:23:40.477Z","comments":true,"path":"2018/12/16/logistic_regression/","link":"","permalink":"http://aier02.com/2018/12/16/logistic_regression/","excerpt":"","text":"​ ​ ​ ​ ​","categories":[{"name":"cs229n","slug":"cs229n","permalink":"http://aier02.com/categories/cs229n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"leetcode linked list","slug":"leetcode_linked_list","date":"2018-11-23T02:00:17.093Z","updated":"2018-12-09T07:13:02.720Z","comments":true,"path":"2018/11/23/leetcode_linked_list/","link":"","permalink":"http://aier02.com/2018/11/23/leetcode_linked_list/","excerpt":"","text":"2. Add Two Numbers（两个链表的对应节点值相加）You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example:123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution:# @return a ListNode def addTwoNumbers(self, l1, l2): #串行进位加法器 carry=0#记录进位 res=n=ListNode(0)#创建结果节点 #依次将l1和l2对应节点的val进行相加，每次加完后将指针往前移一位 while l1 or l2 or carry: #每次循环必须得先初始化两个节点的值为0，再根据节点的情况进行赋值 v1=v2=0 if l1: v1=l1.val l1=l1.next if l2: v2=l2.val l2=l2.next #使用divmod()实现求商和余数，从而得到进位和本位和 carry,val=divmod(v1+v2+carry,10) #创建对应的节点 n.next=ListNode(val) #指定下一个节点 n=n.next return res.next 19. Remove Nth Node From End of List（移除从后往前数的第n个节点）Given a linked list, remove the n-th node from the end of list and return its head.Example:123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Follow up:Could you do this in one pass?12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" #找到从头开始搜索的要移除的节点的位置，记录为t l=1 temp=head.next while temp!=None: l+=1 temp=temp.next t=l-n if t==0: head=head.next else: temp=head j=1 while j&lt;t: temp=temp.next j+=1 temp.next=temp.next.next return head 23. Merge k Sorted Lists（合并k个已经排好序的链表）Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.Example:1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6比较直接的做法是使用经典的合并算法，这里的做法是直接读取所有节点值，然后统一进行排序后以链表的形式进行表示。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" ls=[] for t in lists: while t!=None: ls.append(t.val) t=t.next ls.sort() head=fhead=ListNode(0) for i in range(len(ls)): head.next=ListNode(ls[i]) head=head.next return fhead.next 25. Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.Example:Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;512345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseKGroup(self, head, k): count,node=0,head while node and count&lt;k: node=node.next count+=1 if count&lt;k:return head else: #翻转后返回的是该段翻转之后的头节点prev，和下一个需要翻转的部分的头节点temp temp,prev=self.reverse(head,k) #本段翻转后，原来的head成了尾部，需要和下一段的头进行对接，故每次都要返回翻转之后的头prev head.next=self.reverseKGroup(temp,k) return prev #每次翻转后要保留断开位置的前一个节点和后一个节点 def reverse(self,head,k): prev,cur,nxt=None,head,head while k&gt;0: nxt=cur.next cur.next=prev prev=cur cur=nxt k-=1 return (cur,prev)","categories":[{"name":"algorithms","slug":"algorithms","permalink":"http://aier02.com/categories/algorithms/"}],"tags":[{"name":"linked list","slug":"linked-list","permalink":"http://aier02.com/tags/linked-list/"},{"name":"leetcode","slug":"leetcode","permalink":"http://aier02.com/tags/leetcode/"}]},{"title":"leetcode hash table","slug":"leetcode_hash_table","date":"2018-11-23T01:36:36.136Z","updated":"2018-12-09T07:12:55.099Z","comments":true,"path":"2018/11/23/leetcode_hash_table/","link":"","permalink":"http://aier02.com/2018/11/23/leetcode_hash_table/","excerpt":"","text":"hash table是指对目标值进行一定变换后映射到表中的某个位置（或者某个值），可以用list或者dict实现这个哈希表 1. Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.Example:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].123456789101112class Solution: def twoSum(self, nums, target): if len(nums)&lt;=1: return False else: sum_dict=&#123;&#125; for i in range(len(nums)): if nums[i] in sum_dict: return [sum_dict[nums[i]],i] else: #用key值保存索引值，key对应的value为差值 sum_dict[target-nums[i]]=i这个sum_dict的关键在于他的转换是将数组中每个值与target的差值保存为key，查表时只要查找是否数组中存在这样的差值即可找到相应的两个和为target的元素。 3. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters.Example 1:123Input: \"abcabcbb\"Output: 3 Explanation: The answer is \"abc\", with the length of 3.1234567891011121314class Solution(object): def lengthOfLongestSubstring(self, s): dic, res, start, = &#123;&#125;, 0, 0 for i, ch in enumerate(s): # when char already in dictionary if ch in dic: # check length from start of string to index res = max(res, i-start) # update start of string index to the next index start = max(start, dic[ch]+1) # add/update char to/of dictionary dic[ch] = i # answer is either in the begining/middle OR some mid to the end of string return max(res, len(s)-start)用dict记录每个出现过的字母和他的索引，若遇到重复的字母则更新res和重新记录的开始位置。 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note:The solution set must not contain duplicate quadruplets.Example:12345678Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]]1234567891011121314151617181920212223242526272829303132333435363738class Solution: def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\" #先进行排序，这样做的好处是后期对两个数字进行搜索时可以更加方便的移动l和r指针 nums.sort() results=[] self.findNsum(nums,target,4,[],results) return results def findNsum(self,nums,target,N,result,results): #检查在剩余的nums中查找target的可能性 if len(nums)&lt;N or N&lt;2 or target&lt;nums[0]*N or target&gt;nums[-1]*N: return elif N==2: #在数组中首尾进行搜索和为target的两个位置 l,r=0,len(nums)-1 while l&lt;r: #找到目标值 if target==nums[l]+nums[r]: results.append(result+[nums[l],nums[r]]) l+=1 #当前后l指定的数字相同时，l+1，跳过这个重复的值 while l&lt;r and nums[l-1]==nums[l]: l+=1 #两个指针对应的值和小于target，因为nums[r]已经最大，所以往前移动l elif nums[l]+nums[r]&lt;target: l+=1 #往后移动r else: r-=1 else: #深度优先搜索，每次先确定一个值，在剩余的nums中寻找修改后的target for i in range(len(nums)-N+1): if i==0 or (i&gt;0 and nums[i-1]!=nums[i]): self.findNsum(nums[i+1:],target-nums[i],N-1,result+[nums[i]],results)先对nums进行排序，然后迭代的每次保留一个数字然后往后进行搜索，直到只剩下两个数字时使用两个指针从首尾进行搜索，特别注意相同数字的处理，当两个数字相同时，l要继续往前+1。 30. Substring with Concatenation of All WordsYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.Example 1:123456Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are \"barfoor\" and \"foobar\" respectively.The output order does not matter, returning [9,0] is fine too.Example 2:1234Input: s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]Output: []123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution: def findSubstring(self, s, words): if len(words) == 0: return [] # initialize d, l, ans l = len(words[0]) d = &#123;&#125; #用字典d记录words中出现的各个word的次数 for w in words: if w in d: d[w] += 1 else: d[w] = 1 i = 0 ans = [] # sliding window(s) for k in range(l): #left指针用于指示左端第一个有效字符的起始位置 #count用于记录当前有效的word数目 left = k subd = &#123;&#125; count = 0 #处理开始索引k，k必定在一个l的范围内 for j in range(k, len(s)-l+1, l): tword = s[j:j+l] # valid word，即该字符串出现在words中 if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 #纠正某个单词的数目，若超过了words中的数目则需要进行前向调整 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid #遇到无效的单词时，需要重新计算left的位置，默认下一个单词有效，同时需要重新统计字典 #这种解法关键在于使用两个字典分别统计words中各个单词出现的次数，当统计到的有效单词数目一致时则认为是有效的连续字串 else: left = j + l subd = &#123;&#125; count = 0 return ans这里的hash tabel为一个字典，记录了words中各个单词的数目。 36. Valid SudokuDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:Each row must contain the digits 1-9 without repetition.Each column must contain the digits 1-9 without repetition.Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.Example 1:12345678910111213Input:[ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]Output: true123456789101112131415161718192021class Solution: def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\" #set中存储的是不重复的元素 big = set() for i in range(0,9): for j in range(0,9): if board[i][j]!='.': cur = board[i][j] #记录board中数字出现的列，行，还有所在单独的3x3的区域的位置，9x9分为了9个区域，用两个索引可以表示3x3在9x9的位置 if (i,cur) in big or (cur,j) in big or (int(i/3),int(j/3),cur) in big: return False #一行中是否有重复数字 big.add((i,cur)) #一列中是否有重复数字 big.add((cur,j)) big.add((int(i/3),int(j/3),cur)) return True关键在于如何存储表示第i行出现了某个数字，第j列出现了某个数字，第n个区域出现了某个数字。通过行和列确定区域所在的位置。 37. Sudoku SolverWrite a program to solve a Sudoku puzzle by filling the empty cells.A sudoku solution must satisfy all of the following rules:Each of the digits 1-9 must occur exactly once in each row.Each of the digits 1-9 must occur exactly once in each column.Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.Empty cells are indicated by the character '.'.1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: #检查在(row,col)位置插入k值后是否还是有效的数独板 def isValidSudoku(self, board, row, col, k): for i in range(9): if board[row][i] != '.' and board[row][i] == k: return False for j in range(9): if board[j][col] != '.' and board[j][col] == k: return False r1 = (row // 3) * 3 c1 = (col // 3) * 3 for i in range(r1, r1+3): for j in range(c1, c1+3): if board[i][j] != '.' and board[i][j] == k: return False return True def solveSudoku(self, board): self.board = board self.solve(board) def solve(self, board): \"\"\" :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. \"\"\" for i in range(9): for j in range(9): #找到空缺的位置 if board[i][j] == '.': for k in range(1,10): #检查在（i，j）插入k之后是否有效 if self.isValidSudoku(board, i, j, str(k)): #令（i，j）为k board[i][j] = str(k) #递归检查是否能solve if self.solve(board): return True #无效则回溯 board[i][j] = '.' #进行了所有尝试都无效则返回false return False #前面没有返回flase则成功 return True每次尝试在空缺位置插入一个值，检查插入后board是否还是有效的，无效则进行回溯，尝试下一个值。 49. Group AnagramsGiven an array of strings, group anagrams together.Example:1234567Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],Output:[ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]]12345678910111213141516171819202122232425262728293031323334353637class Solution: def groupAnagrams(self, strs): \"\"\" :type strs: List[str] :rtype: List[List[str]] \"\"\" #字符串匹配问题，如何实现快速匹配而不是一个一个字母匹配 #构造一个hash函数，使得含有相同字母的str都映射到统一个位置 #方法一是进行排序，没有构造hash function \"\"\" dic=&#123;&#125; for s in strs: sp=''.join(sorted(s)) if sp in dic: dic[sp].append(s) else: dic[sp]=[s] return list(dic.values()) \"\"\" #方法二是构造一个tuple记录字母出现的位置 def convert(s): res=[0]*26 for c in s: res[ord(c)-ord('a')]+=1 return tuple(res) #tuple对应的索引 dic=&#123;&#125; #记录结果 res=[] for s in strs: t=convert(s) if t in dic: res[dic[t]].append(s) else: res.append([s]) dic[t]=len(res)-1 return res构造一个tuple表，使得字符串映射到字符位置固定的tuple中，这样做能使得相同字母构造的不同字符串能到映射到相同的位置。hash table的核心思想是使得具有某种规律的输入映射到相同的输出，在python 中用字典的形式存储这种key-value的对应关系，具体的关系要根据实际问题进行设计","categories":[{"name":"algorithms","slug":"algorithms","permalink":"http://aier02.com/categories/algorithms/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://aier02.com/tags/leetcode/"},{"name":"hash table","slug":"hash-table","permalink":"http://aier02.com/tags/hash-table/"}]},{"title":"VGG","slug":"VGG","date":"2018-11-12T03:28:24.262Z","updated":"2018-11-19T11:38:09.607Z","comments":true,"path":"2018/11/12/VGG/","link":"","permalink":"http://aier02.com/2018/11/12/VGG/","excerpt":"","text":"read paper online Abstract主要工作是观察加深网络深度在大型图像分类问题上的效果，使用3x3的卷积核来加深CNNs到16-19层，这种做法使得该模型在ILSVCR2014取得了第一和第二的成绩。 1 INTRODUCTION介绍了今年convnet取得的成就，越来越多人尝试从不同方面改进convnet取实现更高的分类准确率；有的修改感受野的大小，使用小的步长，或者从训练和测试的时候使用图片的大小和数量入手。而本文关注的是convnet的深度，所有卷积层使用的filter均为3x3，增加了整体的深度。结果取得了当时在ILSVR中最好的结果，而且在其他数据集中都是最好的。最后说明了本文各个section和appendix中的主要内容。 2 CONVNET CONFIGURATIONS所有卷积层的配置使用同一个规则。 2.1 ARCHITECTURE固定大小为224x224的RGB图片，预处理是每张图片减去整个训练集图像的RGB均值，卷积核为3x3，另外1x1的卷积核可以看作是输入channel的线性变换，卷积步长为1，padding为1，空间池化为在某些卷积层后使用最大池化层2x2,步长为2，但不是所有卷积层都使用；所有卷积层后接3层fc，前两层为4096个channel的fc，第三层为1000个channel；整个网络的最后一层为sofmax。所有隐藏层都使用Relus作为激活函数，只有一层使用了LRN。 2.2 CONFIGURATIONS卷积层中的channel从64每次经过一个pooling层则翻倍最后到512channel。 2.3 DISCUSSION和目前为止的模型不同之处在于在开始的conv layer不使用大的感受野，而是在整个网络中都只使用3x3，显然两个这样的卷积层堆叠起来的感受野为5x5，中间不经过pooling层，同理3层堆叠为7x7，这样做的作用是一方面把使用3个RLUs替代一个，使得决策函数更加有影响力；另一方面3个3x3的参数相较于一个7x7的参数更少，前者为3(32C2),即27C2,后者为72C2=49C2;","categories":[{"name":"paper","slug":"paper","permalink":"http://aier02.com/categories/paper/"}],"tags":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/tags/cv/"},{"name":"paper reading","slug":"paper-reading","permalink":"http://aier02.com/tags/paper-reading/"}]},{"title":"AlexNet","slug":"AlexNet","date":"2018-10-30T02:56:58.917Z","updated":"2018-11-03T09:23:15.726Z","comments":true,"path":"2018/10/30/AlexNet/","link":"","permalink":"http://aier02.com/2018/10/30/AlexNet/","excerpt":"","text":"read paper online Abstract训练集和测试集均来自ImageNet网络框架的结构为5层conv layer，接一个max pooling和3层fully connected layer训练过程中使用的方法，高效的GPU代码和减少overfitting的dropout项目达到的成就，当时最好的测试误差率 1 Introduction当时的分类方法主要是高效地运用机器学习方法，要提高分类的表现可以从增大数据集、学习更强的模型和减少overfitting入手。更大的数据集:ImageNet数据集拥有1500万张高清图片并且含有22000个种类更好的模型:CNN模型能有效地处理大量的图片，他的参数相较于传统的前向神经网络要少，更加容易去训练。更好的训练方法:在GPU上高效地实现二维卷积能有效地加快训练的过程。该paper特别的贡献，以及当时硬件的限制。 2 The Dataset介绍具体使用的数据集的来源、图片大小、图片种类、图片数量,以及训练过程中加入的图像预处理。paper中使用的pre-processing为图像下采样为256x256，pixel值减去整个训练集的中值，最后使用的是RGB格式的纯pixel值。top1就是你预测的label取最后概率向量里面最大的那一个作为预测结果，你的预测结果中概率最大的那个类必须是正确类别才算预测正确。而top5就是最后概率向量最大的前五名中出现了正确概率即为预测正确。故top-1 error rate 和 top-5 error rate都是在该错误率定义下在test data set中的概率。 3 The Architecture介绍使用的CNN框架中新颖的设计 3.1 ReLU Nonlinearity训练时使用GD 算法,饱和的非线性函数如tanh(x) 和 sigmoid function (1 + e−x)−1 使得训练的时间要比不饱和的非线性函数f(x) = max(0,x),称为Rectified Linear Units要长。通过图例说明饱和的activation function比不饱和的收敛得更慢。 3.2 Training on Multiple GPUs受限于硬件设备，将整个网络(神经元)平分到2个GPU中进行并行计算，GPU能够直接读写别的GPU的内存而不占用主机的内存;两个GPU的沟通只在特定的layer进行,沟通是指两者产生feature maps作为对方的输入,不沟通就是只用该GPU产生的feature maps作为下一层的输入。 3.3 Local Response Normalization（no idea==）Relus不需要为了避免饱和而进行输入的规范化， 3.4 Overlapping Poolingpooling unit的strke和size一致，为tradiitonal local pooling，strike小于size则会发生overlapping。 3.5 Overall Architecturefully connected layers中的神经元是一个和feature map大小一致的filter，全连接层的目的是高度提取特征，将feature map浓缩为一个数字，用于后面的分类或者回归。在最后一个卷积层输出到全连接层中，将输入看作一个neuron表示一张feature map，所有输入都得连接到每一个全连接层的neuron中，该过程和普通的卷积层类似，不同点在于全连接层的每一个w与单个feature map大小一致而且每一个输出都为一个数字，而卷积层的大小自定而且输出为一张feature map。 4 Reducing Overfitting整个网络中有六千万个参数，尽管从image到label的映射中存在10位二进制的约束，但是如此多的参数无可避免会存在过拟合。 4.1 Data Augmentation一般先提及以往的方法，指出不足之处后提出自己的做法，突出自己的优势。在GPU进行训练的过程中，利用CPU对还未训练的图像进行小量的改变，故可以说数据增强在计算代价上面是“免费的”。（CPU的计算代价远小于GPU）图像平移和水平翻转:从原图和翻转后的图像中(256x256)分别随机选取224x224的区域作为增强后的图像进行训练，这种做法虽然增加了训练集的大小，但是显然部分数据存在内部的依赖(那为啥还这么做呢？给出理由),实际情况是不使用这种增强的模式，训练会出现严重的overfitting，迫使使用小的网络，权衡之后这种方式还是有效的。在测试的时候，分别在原图和翻转后的图像定位选取5个子区域，四个角的224x224，还有中心位置的224x224，即一张原图产生了10张用于测试的图像,进行预测时即对这十张图片的softmax得到的值进行平均得到某个class的最大值为预测值。改变训练图像的RGB通道强度，对训练集中的RGB像素进行PCA，然后对三个通道的值进行成比例的修改。(这里没看懂) 4.2 Dropout集成学习对于减少错误率非常有效，但是对于大型的网络而言该做法计算代价太大，dropout能同时兼顾两者，既能实现不同的网络，同时能降低训练成本；对于每一个隐藏层的neuron，以0.5的概率对他的输出进行归零，即该神经元在本次训练(包括fp和bp)均失效；每一个epoch均可能是不同的结构，这种做法会导致训练次数的增多(大致一倍)才使得模型收敛，在test的时候，根据概率论的知识，每一个神经元的输出要乘以0.5，才和训练时的设置保持一致；本文中的dropout在后两层的全连接层实现。 5 Details of learning训练过程中使用了SGD算法，一个batch为128张图片，momentum为0.9，weight decay为0.0005，实验发现这个0.0005对于减少错误率很重要(玄学？)vi+1:=0.9∗vi−0.0005∗ϵ∗wi−ϵ∗&lt;∂L∂W∣wi&gt;Diwi+1:=wi+vi+1v_{i+1}:=0.9*v_{i}-0.0005*\\epsilon*w_i-\\epsilon*&lt;\\frac{\\partial L}{\\partial W}|_{w_i}&gt;_{D_i} w_{i+1}:=w_{i}+v_{i+1}v​i+1​​:=0.9∗v​i​​−0.0005∗ϵ∗w​i​​−ϵ∗&lt;​∂W​​∂L​​∣​w​i​​​​&gt;​D​i​​​​w​i+1​​:=w​i​​+v​i+1​​i是epoch的轮数，v是动量变量，ϵ\\epsilonϵ是learning rate，&lt;∂L∂W∣wi&gt;Di&lt;\\frac{\\partial L}{\\partial W}|_{w_i}&gt;_{D_i}&lt;​∂W​​∂L​​∣​w​i​​​​&gt;​D​i​​​​是在第i次的batch中损失函数关于w的导数的平均值。对于每一层中的w的初始化，使用的是均值为0，标准差为0.01的高斯分布，而对于2，4，5卷积层和全连接层的bias，初始化为1，其他bias初始化为0；使得训练初始阶段Relus有正数输入，训练加快。所有层使用相同的初始化学习率0.01，然后在训练过程中手工调整，启发式做法是当验证的错误率不在减少时，对当前的学习率进行/10操作。 6 Results和其他model进行对比，突出自己的成绩，横向对比。 7 Discussion强调卷积神经网络大且深的重要性，并对未来的工作进行展望，本文为希望用在视频序列帧中。 References所有引用的文章出处。","categories":[{"name":"paper","slug":"paper","permalink":"http://aier02.com/categories/paper/"}],"tags":[{"name":"cv","slug":"cv","permalink":"http://aier02.com/tags/cv/"},{"name":"paper reading","slug":"paper-reading","permalink":"http://aier02.com/tags/paper-reading/"}]},{"title":"backpropagation","slug":"backpropagation","date":"2018-10-29T08:04:42.275Z","updated":"2018-11-21T08:28:53.411Z","comments":true,"path":"2018/10/29/backpropagation/","link":"","permalink":"http://aier02.com/2018/10/29/backpropagation/","excerpt":"","text":"Introductionbackpropagation, which is a way of computing gradients of expressions through recursive application of chain rule. 反向传播算法通过链式法则计算梯度in practice we usually only compute the gradient for the parameters (e.g. W,b) so that we can use it to perform a parameter update.一般实际中计算的是权重的梯度，用于更新权重，也可能计算输入x的梯度，用于可视化和解释是神经网络的工作 Simple expressions and interpretation of the gradientthe derivative on each variable tells you the sensitivity of the whole expression on its value，导函数表明了整个函数对于不同自变量的敏感程度f(x+h)=f(x)+hdf(x)dxf(x + h) = f(x) + h \\frac{df(x)}{dx}f(x+h)=f(x)+h​dx​​df(x)​​表明了f(x)随x变化的幅度，即x变化h后，f(x+h)如何变化,自变量的变化量和函数值的变化量的关系。Even though the gradient is technically a vector, we will often use terms such as “the gradient on x” instead of the technically correct phrase “the partial derivative on x” for simplicity.出于方便，notebook中将对于x的偏导数说成对于x的梯度he derivatives tell us nothing about the effect of such large changes on the inputs of a function; They are only informative for tiny, infinitesimally small changes on the inputs, as indicated by the limh→0\\lim_{h \\rightarrow 0}lim​h→0​​ in its definition. Compound expressions with chain rule利用微积分的知识求某个函数的导数有时候是十分困难的，或者相当的繁琐，这种情况下如何快速求出函数对某个参数的偏导数呢？此时，chain rule就很关键了。譬如存在函数f(x,y,z)=(x+y)zf(x,y,z)=(x+y)zf(x,y,z)=(x+y)z,则使用chain rule有：1234567891011121314# set some inputsx = -2; y = 5; z = -4# perform the forward passq = x + y # q becomes 3f = q * z # f becomes -12# perform the backward pass (backpropagation) in reverse order:# first backprop through f = q * zdfdz = q # df/dz = q, so gradient on z becomes 3dfdq = z # df/dq = z, so gradient on q becomes -4# now backprop through q = x + ydfdx = 1.0 * dfdq # dq/dx = 1. And the multiplication here is the chain rule!dfdy = 1.0 * dfdq # dq/dy = 1 Intuitive understanding of backpropagationEvery gate in a circuit diagram gets some inputs and can right away compute two things: 1. its output value and 2. the local gradient of its inputs with respect to its output value.将函数拆分为各个初等函数的混合计算，可视化为一个circuit diagram，图中的每个节点为一个基本计算。每个节点都可以独立计算他的output和local gradientBackpropagation can thus be thought of as gates communicating to each other (through the gradient signal) whether they want their outputs to increase or decrease (and how strongly), so as to make the final output value higher Modularity: Sigmoid examplesigmoid function(logistic function):\\sigma(x) = \\frac{1}{1+e^{-x}} \\\\\\\\ \\rightarrow \\hspace{0.3in} \\frac{d\\sigma(x)}{dx} = \\frac{e^{-x}}{(1+e^{-x})^2} = \\left( \\frac{1 + e^{-x} - 1}{1 + e^{-x}} \\right) \\left( \\frac{1}{1+e^{-x}} \\right) = \\left( 1 - \\sigma(x) \\right) \\sigma(x)","categories":[{"name":"cs231n","slug":"cs231n","permalink":"http://aier02.com/categories/cs231n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"},{"name":"chain rule","slug":"chain-rule","permalink":"http://aier02.com/tags/chain-rule/"},{"name":"backpropagation","slug":"backpropagation","permalink":"http://aier02.com/tags/backpropagation/"}]},{"title":"leetcode summary 26-30","slug":"leetcode-summary-26-30","date":"2018-10-24T03:20:21.962Z","updated":"2018-10-30T02:56:49.273Z","comments":true,"path":"2018/10/24/leetcode-summary-26-30/","link":"","permalink":"http://aier02.com/2018/10/24/leetcode-summary-26-30/","excerpt":"","text":"26. Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place, such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.题目有另外的提示就是要求返回一个int值的length，检测器就会检查modified的nums前length个值是否为排除了重复值后的正确答案。1234567891011121314151617class Solution: def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" if len(nums)&lt;=1:return len(nums) l,r,length=0,1,len(nums) while True: if r==length: break else: if nums[r]&gt;nums[l]: l+=1 nums[l]=nums[r] r+=1 return l+1使用两个pointer对nums数组进行遍历，每发现一个新的元素，则后一个pointer l+1，同时赋值nums[l]为nums[r]，r指针用于遍历数组,最终使得nums的前l+1个元素均不重复。 27. Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.1234567891011121314151617181920212223242526272829class Solution: def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" if val not in nums:return len(nums) res=0 l,r,length=0,1,len(nums) while True: if r&gt;=length or l&gt;=length: break else: if nums[l]==val: if nums[r]!=val: nums[l]=nums[r] nums[r]=val l+=1 r+=1 else: r+=1 else: l+=1 r=l+1 for num in nums: if num!=val: res+=1 return res使用两个pointer，l指针寻找等于val的索引，r指针寻找在l之后的位置中不等于val的索引，若找到满足条件的r，则交换l和r索引指示的位置的值，l+1往后继续寻找val的位置，注意r无论如何必定在l之后。 28. Implement strStr()Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.For the purpose of this problem, we will return 0 when needle is an empty string1234567891011121314151617181920212223242526272829303132class Solution: def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" ph,pn,hlength,nlength=0,0,len(haystack),len(needle) num=0 flag=0 res=0 while True: if num==nlength or ph==hlength: break else: if haystack[ph]==needle[pn]: if flag==0: flag=1 res=ph pn+=1 num+=1 else: if flag==1: pn=0 num=0 flag=0 ph=res ph+=1 if num==nlength: return res else: return -1使用两个pointer分别遍历haystack和needle，tips在于使用flag表示是否找到两者一样的初始char，同时res记录第一个相同在haystack中的位置，前向遍历时若发现两个字母不相同，则检查flag是否为1，若为1则表示部分匹配，此时需要重置needle的指针pn和haystack指针ph为刚才记录的位置(后面会+1，表示继续往前找，而不用管前面的字母).方法二：利用python的切片特性，没有使用两个指针123456789101112131415def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" a = len(needle) b = len(haystack) i = 0 while a &lt;= b: if needle == haystack[i:i+a]: return i i += 1 b -= 1 return -1 29. Divide Two IntegersGiven two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.Return the quotient after dividing dividend by divisor.The integer division should truncate toward zero.123456789101112131415class Solution: def divide(self, dividend, divisor): \"\"\" :type dividend: int :type divisor: int :rtype: int \"\"\" if dividend==0:return 0 i,result,p,q=map(abs,(0,0,dividend,divisor)) while q&lt;&lt;i &lt;=p:i+=1 for j in reversed(range(i)): if q&lt;&lt;j &lt;=p: p,result=p-(q&lt;&lt;j),result+(1&lt;&lt;j) if (dividend&lt;0)!=(divisor&lt;0) or result&lt;(-1&lt;&lt;31):result=-result return min(result,(1&lt;&lt;31)-1)使用移位操作实现乘除，基于二进制的思想，统计最多移位的位数，然后想平常手工计算两个数相除一样，上一位，除数变小，在继续同样的步骤。 30. Substring with Concatenation of All WordsYou are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.class Solution:​ def findSubstring(self, s, words):​ if len(words) == 0:​ return []# initialize d, l, ans​ l = len(words[0])​ d = {}​ for w in words:​ if w in d:​ d[w] += 1​ else:​ d[w] = 1​ i = 0​ ans = []12345678910111213141516171819202122232425262728293031# sliding window(s)for k in range(l):#left指针用于指示左端第一个有效字符的起始位置#count用于记录当前有效的word数目 left = k subd = &#123;&#125; count = 0 for j in range(k, len(s)-l+1, l): tword = s[j:j+l] # valid word if tword in d: if tword in subd: subd[tword] += 1 else: subd[tword] = 1 count += 1 #纠正某个单词的数目，若超过了words中的数目则需要进行前向调整 while subd[tword] &gt; d[tword]: subd[s[left:left+l]] -= 1 left += l count -= 1 if count == len(words): ans.append(left) # not valid #遇到无效的单词时，需要重新计算left的位置，默认下一个单词有效，同时需要重新统计字典 #这种解法关键在于使用两个字典分别统计words中各个单词出现的次数，当统计到的有效单词数目一致时则认为是有效的连续子串 else: left = j + l subd = &#123;&#125; count = 0return ans一开始的想法是通过寻找words中所有可能的单词搭配，组合数为n!，苦于寻找快速找到所有组合的方法，在看了discussion后发现自己其实没有很好的理解题目，其实问题的关键是找到由words中单词随意组成的子串的位置，并不要求返回具体的子串是什么，同样不关注子串是否重复，所以比较理想的方法是不用字符串匹配，毕竟倘若要字符串匹配，需要做到每一个字符进行比较；使用字典的形式统计单词出现的次数，同样能实现题目的要求。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://aier02.com/categories/leetcode/"}],"tags":[{"name":"array","slug":"array","permalink":"http://aier02.com/tags/array/"},{"name":"two pointers","slug":"two-pointers","permalink":"http://aier02.com/tags/two-pointers/"},{"name":"backtracking","slug":"backtracking","permalink":"http://aier02.com/tags/backtracking/"}]},{"title":"leetcode summary 20-25","slug":"leetcode_summary_20-25","date":"2018-10-24T01:07:58.319Z","updated":"2018-10-29T08:04:24.604Z","comments":true,"path":"2018/10/24/leetcode_summary_20-25/","link":"","permalink":"http://aier02.com/2018/10/24/leetcode_summary_20-25/","excerpt":"","text":"20 Valid ParenthesesGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid.利用stack的后进新出的特性对输入尽心匹配123456789101112131415161718192021222324class Solution(object): def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" mdict = &#123;')':'(','&#125;':'&#123;',']':'['&#125; my_stack = [] for item in s: if mdict.get(item): #check if item is closing parentheses if my_stack == []: # if it is closing and stack is empty - return false return False if mdict.get(item) != my_stack.pop(): return False else: # if not - add to stack my_stack.append(item) return my_stack == []关键在于创建一个stack用于存储所有开括号，python中list自带pop函数使得list成为一个栈；依次读取s的值，每当遇到一个闭括号，则检查stack非空且顶端的符号是否为对应的开括号，是则正确关闭，否则error；每遇到一个开括号则放入栈中，等待匹配；开闭括号的对应关系通过dict存储。###21 Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.For example, given n = 3, a solution set is:1234567[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]回溯算法的定义：回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法。适用于求解组合数较大的问题。对于回溯问题，总结出一个递归函数模板，包括以下三点递归函数的开头写好跳出条件，满足条件才将当前结果加入总结果中已经拿过的数不再拿 if(s.contains(num)){continue;}遍历过当前节点后，为了回溯到上一步，要去掉已经加入到结果list中的当前节点。12345678910111213141516171819202122232425262728class Solution: def generateParenthesis(self, n): \"\"\" :type n: int :rtype: List[str] \"\"\" path,result='',[] self.backtrack(n,0,0,path,result) return result def backtrack(self,n,num_open,num_close,path,result): if num_close==n: result.append(path) return else: if num_open&lt;n: path+='(' num_open+=1 self.backtrack(n,num_open,num_close,path,result) #回退到前一步 path=path[:-1] num_open-=1 if num_close&lt;num_open: path+=')' num_close+=1 self.backtrack(n,num_open,num_close,path,result) #path=path[:-1] #num_close-=1 returnbacktrack函数体现了回溯算法的思想，实际上类似于dfs，当“不满足条件时则回退到上一步”,在代码实现中则是通过回退num_open或者num_close的值和path实现这一操作，因为添加path的操作实际只有两种，添加“(”或者“)”，故根据if的顺序，在python中如果为顺序执行if的话，只用回退第一个if即可，若两个if的顺序不确定，更加规范的操作是都得回退。在运行过程中，“不满足条件”编码实现为“满足条件则加入到result中”，这种做法实际上更加符合枚举的想法;该代码实际上是每一个位置先加“(”进行深度优先搜索，直到找到满足条件的path，然后回退到该位置，添加“)”继续进行深度优先搜索。 23. Merge k Sorted ListsMerge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.Example:1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;61234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeKLists(self, lists): \"\"\" :type lists: List[ListNode] :rtype: ListNode \"\"\" ls=[] for t in lists: while t!=None: ls.append(t.val) t=t.next ls.sort() head=fhead=ListNode(0) for i in range(len(ls)): head.next=ListNode(ls[i]) head=head.next return fhead.next没有使用递归依次计算两个sorted lists，而是直接获取所有链表中的数值，然后sort()，根据得到的已经排好序的序列创建新的链表，明显时间复杂度为O(n)（忽略list自带的sort()函数的时间复杂度） 24. Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head.Example:1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Note:Your algorithm should use only constant extra space.You may not modify the values in the list’s nodes, only nodes itself may be changed.123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" if head==None or head.next==None: return head else: temp=head cur=head.next prev=None root=cur while True: node=cur.next cur.next=temp temp.next=node if prev==None: prev=temp else: prev.next=cur prev=temp if node==None or node.next==None: break cur=node.next temp=node return root每两个节点互换并且不能只更改node的val，则只需处理节点之间的next关系，每次对两个节点进行操作，比如1-&gt;2-&gt;3-&gt;4,将2的next指向1，1的next指向3，同时注意另存一个节点记录前一组的最后一个节点，即该例子中的1，3，用于连接前一组转换后的的最后一个节点和后一组转换后的第一个节点，即例子中的1.next指向4.翻转的关键在于指定节点prev。 25. Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.Example:Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5Note:Only constant extra memory is allowed.You may not alter the values in the list’s nodes, only nodes itself may be changed.针对整个链表的翻转实现,注意每次只要处理一个节点cur和该节点的前向节点prev，同时在改变cur的next之前另存nxt指向原来的next节点，以便于完成一对节点的翻转后cur指向cur的next。123456789101112class Solution: def reverseList(self, head): if not head or not head.next: return head #prev,cur,nxt分别记录前一个节点，正在处理的节点和后一个节点 prev, cur, nxt = None, head, head while cur: nxt = cur.next cur.next = prev prev = cur cur = nxt return prev扩展到k个节点的翻转，每次翻转k个节点的链表:1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: #处理分组和组间的连接关系 def reverseKGroup(self, head, k): count, node = 0, head while node and count &lt; k: node = node.next count += 1 if count &lt; k: return head new_head, prev = self.reverse(head, count) head.next = self.reverseKGroup(new_head, k) return prev #处理每一个组的k个节点的翻转 def reverse(self, head, count): prev, cur, nxt = None, head, head while count &gt; 0: nxt = cur.next cur.next = prev prev = cur cur = nxt count -= 1 return (cur, prev)关键在于reverse函数返回值cur指示连续的k个节点翻转后的下一个节点，最为新的head节点，prev指示前一组翻转后的节点的最后一个节点，用于和前前一组的原头节点(即翻转后的尾节点)进行连接。实际问题的关键在于将整条链表以k个节点为一组进行划分，每次对k个节点的子链表进行翻转，对于某个子链表，翻转后要注意确定他的下一组的头节点new_head，从而获得他的下一组翻转后的头节点prev，将改子链表翻转后的尾节点，即原来的头节点和他的下一组的翻转后的头节点连接起来，同时要返回该子链表翻转后的头节点prev，供他的前一组使用。总而言之就是要注意每一组翻转前后的头尾节点，处理相邻组的连接关系。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://aier02.com/categories/leetcode/"}],"tags":[{"name":"backtracking","slug":"backtracking","permalink":"http://aier02.com/tags/backtracking/"},{"name":"linked list","slug":"linked-list","permalink":"http://aier02.com/tags/linked-list/"},{"name":"string","slug":"string","permalink":"http://aier02.com/tags/string/"},{"name":"stack","slug":"stack","permalink":"http://aier02.com/tags/stack/"}]},{"title":"common knowledge","slug":"common_knowledge","date":"2018-10-13T02:28:06.184Z","updated":"2018-10-30T02:57:03.946Z","comments":true,"path":"2018/10/13/common_knowledge/","link":"","permalink":"http://aier02.com/2018/10/13/common_knowledge/","excerpt":"","text":"NP问题NP问题:首先需要介绍P(Polynomial,多项式)问题.P问题是可以在多项式时间内被确定机(通常意义的计算机)解决的问题.NP(Non-Deterministic Polynomial, 非确定多项式)问题,是指可以在多项式时间内被非确定机(他可以猜,他总是能猜到最能满足你需要的那种选择,如果你让他解决n皇后问题,他只要猜n次就能完成----每次都是那么幸运)解决的问题.这里有一个著名的问题----千禧难题之首,是说P问题是否等于NP问题,也即是否所有在非确定机上多项式可解的问题都能在确定机上用多项式时间求解###L1-norm和L2-norml1-norm是指曼哈顿距离，即向量的各个元素的绝对值之和；l2-norm是指欧几里得距离，即向量的各个元素的平方和。Lp范数是指向量的各元素的p次方之和开p次方鲁棒性（Robustness）：最小绝对值偏差的方法应用领域很广，相比最小均方的方法，它的鲁棒性更好，LAD能对数据中的异常点有很好的抗干扰能力，异常点可以安全的和高效的忽略，这对研究帮助很大。如果异常值对研究很重要，最小均方误差则是更好的选择。对于L2-norm，由于是均方误差，如果误差&gt;1的话，那么平方后，相比L1-norm而言，误差就会被放大很多。因此模型会对样例更敏感。如果样例是一个异常值，模型会调整最小化异常值的情况，以牺牲其它更一般样例为代价，因为相比单个异常样例，那些一般的样例会得到更小的损失误差内置的特征选择（Built-in feature selection）：这是L1-norm经常被提及的一个优点，而L2-norm没有。这实际上是L1-norm的一个结果，L1-norm往往会使系数变得稀疏（sparse coefficients）。假设模型有100个系数，但是有10个非零的系数，这就是说，其它90个预测器在预测目标值上是没有用的。L2-norm往往会有非稀疏的系数（non-sparse coefficients），没有这个特点。稀疏性（Sparsity）：这主要是一个向量或矩阵中只有很少的非零（non-zero）条目（entries）。L1-norm有能产生许多零值或非常小的值的系数的属性，很少有大的系数。L1-norm得到的稀疏矩阵能用于选择特征，稀疏矩阵中大多数为0，即对loss没用的特征，故只需关注少数非0的特征；稀疏矩阵指的是很多元素为0，只有少数元素是非零值的矩阵，即得到的线性回归模型的大部分系数都是0. 通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，或者贡献微小（因为它们前面的系数是0或者是很小的值，即使去掉对模型也没有什么影响），此时我们就可以只关注系数是非零值的特征。这就是稀疏模型与特征选择的关系","categories":[{"name":"cs231n","slug":"cs231n","permalink":"http://aier02.com/categories/cs231n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"CS231n-2017-Summary","slug":"CS231n_2017_Summary","date":"2018-10-08T14:46:19.006Z","updated":"2018-12-17T02:48:08.053Z","comments":true,"path":"2018/10/08/CS231n_2017_Summary/","link":"","permalink":"http://aier02.com/2018/10/08/CS231n_2017_Summary/","excerpt":"","text":"Something new to me when I read such a good notebook about CS231n-2017-Summary CNNs常用same策略同时保存图像边缘信息Padding strategy:in order to maintain our full size of the input. If we didn’t do padding zero the input will be shrinking too fast and we will lose a lot of data.Give a stride of 1 its common to pad to this equation: (F-1)/2 where F is the filter size, zero padding from both sides.If we pad this way we call this same convolution.If we have input of shape (32,32,3) and ten filters with shape is (5,5) with stride 1 and pad 2;Output size will be (32,32,10) # We maintain the size.Size of parameters per filter = 5x5x3 + 1 = 76(+1 for bias)All parameters 76x10=760So here are the parameters for the Conv layer:Number of filters K.Usually a power of 2.Spatial content size F.3,5,7 …The stride S.Usually 1 or 2 (If the stride is big there will be a downsampling but different of pooling)Amount of PaddingIf we want the input shape to be as the output shape, based on the F if 3 its 1, if F is 5 the 2 and so on一般而言pooling层是不可(用)学习的Pooling makes the representation smaller and more manageable.Pooling Operates over each activation map independently.Example of pooling is the maxpooling.Parameters of max pooling is the size of the filter and the stride&quot;Example 2x2 with stride 2 # Usually the two parameters are the same 2 , 2Also example of pooling is average pooling.In this case it might be learnable. Training neural networks IAs a revision here are the Mini batch stochastic gradient descent algorithm steps,小批量的随机梯度下降算法的步骤:Loop:Sample a batch of data.Forward prop it through the graph (network) and get loss.(define loss)Backprop to calculate the gradients.(chain rule)Update the parameters using the gradients(learning rate)Activation functions,用于引入非线性因素，单纯的线性模型表达能力不足。Sigmoid:Squashes the numbers between [0,1]Used as a firing rate like human brains.Sigmoid(x) = 1 / (1 + e^-x)Problems with sigmoid:big values neurons kill the gradients.Gradients are in most cases near 0 (Big values/small values), that kills the updates if the graph/network are large.Not Zero-centered.Didn’t produce zero-mean data.exp() is a bit compute expensive.just to mention. We have a more complex operations in deep learning like convolution.Tanh:Squashes the numbers between [-1,1]Zero centered.Still big values neurons “kill” the gradients.Tanh(x) is the equation.tanh(x)=sinh(x)cosh(x)tanh(x)=\\frac {sinh(x)}{cosh(x)}tanh(x)=​cosh(x)​​sinh(x)​​,sinh(x)=ex−e−x2sinh(x)=\\frac {e^{x}-e^{-x}}{2}sinh(x)=​2​​e​x​​−e​−x​​​​,cosh(x)=ex+e−x2cosh(x)=\\frac {e^{x}+e^{-x}}{2}cosh(x)=​2​​e​x​​+e​−x​​​​,Proposed by Yann Lecun in 1991RELU (Rectified linear unit):RELU(x) = max(0,x)Doesn’t kill the gradients.Only small values that are killed. Killed the gradient in the halfComputationally efficient.Converges much faster than Sigmoid and Tanh (6x)More biologically plausible than sigmoid.Proposed by Alex Krizhevsky in 2012 Toronto university. (AlexNet)Problems:Not zero centered.If weights aren’t initialized good, maybe 75% of the neurons will be dead and thats a waste computation. But its still works. This is an active area of research to optimize this.To solve the issue mentioned above, people might initialize all the biases by 0.01Leaky RELU:leaky_RELU(x) = max(0.01x,x)Doesn’t kill the gradients from both sides.Computationally efficient.Converges much faster than Sigmoid and Tanh (6x)Will not die.PRELU is placing the 0.01 by a variable alpha which is learned as a parameter.Exponential linear units (ELU):1234ELU(x) = &#123; x if x &gt; 0 alpah *(exp(x) -1) if x &lt;= 0 # alpah are a learning parameter&#125;It has all the benefits of RELUCloser to zero mean outputs and adds some robustness to noise.problemsexp() is a bit compute expensive.Maxout activations:maxout(x) = max(w1.T*x + b1, w2.T*x + b2)Generalizes RELU and Leaky RELUDoesn’t die!Problems:oubles the number of parameters per neuronIn practice:Use RELU. Be careful for your learning rates.Try out Leaky RELU/Maxout/ELUTry out tanh but don’t expect much.Don’t use sigmoid!Data preprocessing:Normalize the data:减去均值后除以标准差1234567# Zero centered data. (Calculate the mean for every input).# On of the reasons we do this is because we need data to be between positive and negative and not all the be negative or positive. X -= np.mean(X, axis = 1)#np.mean()中的参数axis指定了哪个维度被压缩成1，例如axis=0,则输出的结果为一行，即求得输入x的每一列的平均，压缩成一行，同理axis=1，则输出为一列，该结果中的每一行为按照行进行平均的值。# Then apply the standard deviation. Hint: in images we don't do this.X /= np.std(X, axis = 1)To normalize images:对图像进行标准化Subtract the mean image (E.g. Alexnet)Mean image shape is the same as the input images.Or Subtract per-channel meanMeans calculate the mean for each channel of all images. Shape is 3 (3 channels)First idea is to initialize the w’s with small random numbers:12W = 0.01 * np.random.rand(D, H)# Works OK for small networks but it makes problems with deeper networks!The standard deviations is going to zero in deeper networks. and the gradient will vanish sooner in deep networks.使用任意小的数字进行对w初始化，随着网络的加深可能导致梯度消失问题(每一层的输入很小)。12W = 1 * np.random.rand(D, H) # Works OK for small networks but it makes problems with deeper networks!The network will explode with big numbers!，使用大于一的初值可能会导致深层网络中梯度爆炸问题。Xavier initialization:1W = np.random.rand(in, out) / np.sqrt(in)It works because we want the variance of the input to be as the variance of the output.But it has an issue, It breaks when you are using RELU.He initialization(Solution for the RELU issue):1W = np.random.rand(in, out) / np.sqrt(in/2)Solves the issue with RELU. Its recommended when you are using RELUBatch normalization:is a technique to provide any layer in a Neural Network with inputs that are zero mean/unit variance.It speeds up the training. You want to do this a lot.Made by Sergey Ioffe and Christian Szegedy at 2015.We make a Gaussian activations in each layer. by calculating the mean and the variance.Usually inserted after (fully connected or Convolutional layers) and (before nonlinearity).Steps (For each output of a layer)First we compute the mean and variance^2 of the batch for each feature.We normalize by subtracting the mean and dividing by square root of (variance^2 + epsilon)epsilon to not divide by zeroThen we make a scale and shift variables:1Result = gamma * normalizedX + betagamma and beta are learnable parameters.it basically possible to say “Hey!! I don’t want zero mean/unit variance input, give me back the raw input - it’s better for me.”Hey shift and scale by what you want not just the mean and variance!Baby sitting the learning processPreprocessing of data.Choose the architecture.Make a forward pass and check the loss (Disable regularization). Check if the loss is reasonable.Add regularization, the loss should go up!Disable the regularization again and take a small number of data and try to train the loss and reach zero loss.You should overfit perfectly for small datasets.Take your full training data, and small regularization then try some value of learning rate.If loss is barely changing, then the learning rate is small.If you got NAN then your NN exploded and your learning rate is high.Get your learning rate range by trying the min value (That can change) and the max value that doesn’t explode the network.Do Hyperparameters optimization to get the best hyperparameters values.Hyperparameter OptimizationTry Cross validation strategy.Run with a few ephocs, and try to optimize the ranges.Its best to optimize in log space.Adjust your ranges and try again.Its better to try random search instead of grid searches (In log space) Training neural networks IIOptimization algorithms:Problems with stochastic gradient descent:随机梯度下降算法的问题if loss quickly in one direction and slowly in another (For only two variables), you will get very slow progress along shallow dimension, jitter along steep direction. Our NN will have a lot of parameters then the problem will be more.Local minimum or saddle points；局部最小或者鞍点问题何为鞍点？鞍点（Saddle point）在微分方程中，沿着某一方向是稳定的，另一条方向是不稳定的奇点，叫做鞍点。在泛函中，既不是极大值点也不是极小值点的临界点，叫做鞍点。在矩阵中，一个数在所在行中是最大值，在所在列中是最小值，则被称为鞍点。在物理上要广泛一些，指在一个方向是极大值，另一个方向是极小值的点If SGD went into local minimum we will stuck at this point because the gradient is zero.遇到极小值点会stuckAlso in saddle points the gradient will be zero so we will stuck.Saddle points says that at some point:鞍点在gradient上的表现Some gradients will get the loss up.Some gradients will get the loss down.And that happens more in high dimensional (100 million dimension for example)The problem of deep NN is more about saddle points than about local minimum because deep NN has high dimensions (Parameters)Mini batches are noisy because the gradient is not taken for the whole batch.SGD + momentum:引入momentum，解决在鞍点或者极小值点处出现gradient为0而无法及继续更新参数的情况Build up velocity as a running mean of gradients:123# Computing weighted average. rho best is in range [0.9 - 0.99]V[t+1] = rho * v[t] + dxx[t+1] = x[t] - learningRate * V[t+1]V[0] is zero.Solves the saddle point and local minimum problems.It overshoots the problem and returns to it back.Nestrov momentum:1234dx = compute_gradient(x)old_v = vv = rho * v - learning_rate * dxx+= -rho * old_v + (1+rho) * vAdaGrad12345678grad_squared = 0while(True): dx = compute_gradient(x) # here is a problem, the grad_squared isn't decayed (gets so large) grad_squared += dx * dx x -= (learning_rate*dx) / (np.sqrt(grad_squared) + 1e-7)RMSProp12345678grad_squared = 0while(True): dx = compute_gradient(x) #Solved ADAgra grad_squared = decay_rate * grad_squared + (1-grad_squared) * dx * dx x -= (learning_rate*dx) / (np.sqrt(grad_squared) + 1e-7)People uses this instead of AdaGradAdam,最常用的优化器，结合了momentum和RMSPropCalculates the momentum and RMSProp as the gradients.It need a Fixing bias to fix starts of gradients.Is the best technique so far runs best on a lot of problems.With beta1 = 0.9 and beta2 = 0.999 and learning_rate = 1e-3 or 5e-4 is a great starting point for many models!Learning decay学习率退火，避免因为网络的不断加深而导致学习率相对参数而言过大Ex. decay learning rate by half every few epochs.To help the learning rate not to bounce out.Learning decay is common with SGD+momentum but not common with Adam.Dont use learning decay from the start at choosing your hyperparameters. Try first and check if you need decay or not.Regularization:损失函数中引入正则化项；集成学习；drop out修改网络结构；数据增强So far we have talked about reducing the training error, but we care about most is how our model will handle unseen data!上述优化更多的是在做如何更新参数使得error减少，但我们更加关心的是模型的泛化能力What if the gab of the error between training data and validation data are too large?This error is called high variance.Model Ensemble:Algorithm:Train multiple independent models of the same architecture with different initializations.At test time average their results.It can get you extra 2% performance.It reduces the generalization error.You can use some snapshots of your NN at the training ensembles them and take the results.Regularization solves the high variance problem. We have talked about L1, L2 Regularization.L0-norm用于统计向量中非零元素的个数Some Regularization techniques are designed for only NN and can do better.Drop out:使得activation 函数失效，即让其输出在任何输入下都为0In each forward pass, randomly set some of the neurons to zero. Probability of dropping is a hyperparameter that are 0.5 for almost cases.训练过程中随机将部分神经元设置为失活So you will chooses some activation and makes them zero.It works because:It forces the network to have redundant representation; prevent co-adaption of features!If you think about this, It ensemble some of the models in the same model!相当于集成学习，在一个模型中将他的多个不同的子模型进行集成At test time we might multiply each dropout layer by the probability of the dropout.Sometimes at test time we don’t multiply anything and leave it as it is.With drop out it takes more time to train.Dropout是一种在深度学习环境中应用的正规化手段。它是这样运作的：在一次循环中我们先随机选择神经层中的一些单元并将其临时隐藏，然后再进行该次循环中神经网络的训练和优化过程。在下一次循环中，我们又将隐藏另外一些神经元，如此直至训练结束。在训练时，每个神经单元以概率p被保留(dropout丢弃率为1-p)；在测试阶段，每个神经单元都是存在的，权重参数w要乘以p，成为：pw。测试时需要乘上p的原因：考虑第一隐藏层的一个神经元在dropout之前的输出是x，那么dropout之后的期望值是E=px+(1−p)0 ，在测试时该神经元总是激活，为了保持同样的输出期望值并使下一层也得到同样的结果，需要调整x→pxx→px. 其中p是Bernoulli分布（0-1分布）中值为1的概率Data augmentation:Another technique that makes Regularization.Change the data!For example flip the image, or rotate it.Example in ResNet:Training: Sample random crops and scales:Pick random L in range [256,480]Resize training image, short side = LSample random 224x224 patch.Testing: average a fixed set of cropsResize image at 5 scales: {224, 256, 384, 480, 640}For each size, use 10 224x224 crops: 4 corners + center + flipsApply Color jitter or PCATranslation, rotation, stretching.Drop connectLike drop out idea it makes a regularization.Instead of dropping the activation, we randomly zeroing the weights.Transfer learning:Some times your data is overfitted by your model because the data is small not because of regularization.自己的数据集太小You need a lot of data if you want to train/use CNNs.Steps of transfer learningTrain on a big dataset that has common features with your dataset. Called pretraining.找到一个和你的小的数据集特征类似的大的数据集，并用你的模型在该数据集中进行训练Freeze the layers except the last layer and feed your small dataset to learn only the last layer.将模型中除了最后一层外的所有层结构进行冻结，然后在小的数据集中进行训练，以学习最后一层Not only the last layer maybe trained again, you can fine tune any number of layers you want based on the number of data you have Deep learning softwareCPU vs GPUGPU The graphics card was developed to render graphics to play games or make 3D media,. etc.NVIDIA vs AMDDeep learning choose NVIDIA over AMD GPU because NVIDIA is pushing research forward deep learning also makes it architecture more suitable for deep learning.CPU has fewer cores but each core is much faster and much more capable; great at sequential tasks. While GPUs has more cores but each core is much slower “dumber”; great for parallel tasks.CPU的核心更少，但是更快，胜任串行任务；GPU的核心更多，但是更慢，胜任并行任务GPU cores needs to work together. and has its own memory.GPU各个核心需要并行工作，而且GPU有自己的内存，称为显存Matrix multiplication is from the operations that are suited for GPUs. It has MxN independent operations that can be done on parallel.矩阵乘法适用于GPU中Convolution operation also can be paralyzed because it has independent operations.卷积操作也能并行化Programming GPUs frameworks:CUDA(NVIDIA only)Write c-like code that runs directly on the GPU.Its hard to build a good optimized code that runs on GPU. Thats why they provided high level APIs.Higher level APIs: cuBLAS, cuDNN, etcCuDNN has implemented back prop. , convolution, recurrent and a lot more for you!In practice you won’t write a parallel code. You will use the code implemented and optimized by others!If you aren’t careful, training can bottleneck on reading data and transferring to GPU. So the solutions are:训练过程中在读取数据和迁移到gpu的过程中可能出现瓶颈Read all the data into RAM. # If possible将所有数据读如到内存Use SSD instead of HDD使用固态硬盘Use multiple CPU threads to prefetch data!使用多条CPU线程去预读取数据While the GPU are computing, a CPU thread will fetch the data for you.A lot of frameworks implemented that for you because its a little bit painful!Deep learning FrameworksIts super fast moving!Currently available frameworks:Tensorflow (Google)Caffe (UC Berkeley)Caffe2 (Facebook)Torch (NYU / Facebook)PyTorch (Facebook)Theano (U monteral)Paddle (Baidu)CNTK (Microsoft)MXNet (Amazon)The instructor thinks that you should focus on Tensorflow and PyTorch.The point of deep learning frameworks:Easily build big computational graphs.方便地构建计算图Easily compute gradients in computational graphs.方便地通过计算图计算梯度Run it efficiently on GPU (cuDNN - cuBLAS)支持GPUNumpy doesn’t run on GPU.Numpy不能使用GPUMost of the frameworks tries to be like NUMPY in the forward pass and then they compute the gradients for you.很多框架尽力去靠拢NUMPY，同时又能支持GPU**Tensorflow (Google)**静态架构Code are two parts:Define computational graph.定义好计算图Run the graph and reuse it many times.运行计算图并多次使用Tensorflow uses a static graph architecture.静态的图结构Tensorflow variables live in the graph. while the placeholders are feed each run.variable在计算图中生存，placeholders用于在计算图中占位，运行时填入数据Global initializer function initializes the variables that lives in the graph.Use predefined optimizers and losses.使用预先定义的优化器和损失函数You can make a full layers with layers.dense function.Keras(High level wrapper):Keras is a layer on top pf Tensorflow, makes common things easy to do.So popular!Trains a full deep NN in a few lines of codes.There are a lot high level wrappers:KerasTFLearnTensorLayertf.layers #Ships with tensorflowtf-Slim #Ships with tensorflowtf.contrib.learn #Ships with tensorflowSonnet # New from deep mindTensorflow has pretrained models that you can use while you are using transfer learning.迁移学习的时候可以使用多个预训练模型Tensorboard adds logging to record loss, stats. Run server and get pretty graphs! Tensorboard添加了日志用于跟踪损失It has distributed code if you want to split your graph on some nodes.Tensorflow is actually inspired from Theano. It has the same inspirations and structure.PyTorch (Facebook)Has three layers of abstraction:Tensor: ndarraybut runs on GPU,Like numpy arrays in tensorflowVariable: Node in a computational graphs; stores data and gradient #Like Tensor, Variable, PlaceholdersModule: A NN layer; may store state or learnable weights#Like tf.layers in tensorflowIn PyTorch the graphs runs in the same loop you are executing which makes it easier for debugging. This is called a dynamic graph.动态图架构，容易进行debuggingIn PyTorch you can define your own autograd functions by writing forward and backward for tensors. Most of the times it will implemented for you.一般只用重写forward函数Torch.nn is a high level api like keras in tensorflow. You can create the models and go on and on.You can define your own nn module!Also Pytorch contains optimizers like tensorflow.It contains a data loader that wraps a Dataset and provides minbatches, shuffling and multithreading.自己编写数据加载器很重要PyTorch contains the best and super easy to use pretrained modelsPyTorch contains Visdom that are like tensorboard. but Tensorboard seems to be more powerful.提供Visdom用于记录日志PyTorch is new and still evolving compared to Torch. Its still in beta state.PyTorch is best for research.对于research更加常用Tensorflow builds the graph once, then run them many times (Called static graph)定义一次网络即可多次使用，有专门的保存方式,在工业中更常用In each PyTorch iteration we build a new graph (Called dynamic graph)每次使用都要重新搭建网络,在研究中更常用Tensorflow fold make dynamic graphs easier in Tensorflow through dynamic batching.Dynamic graph applications include: recurrent networks and recursive networks.Caffe2 uses static graphs and can train model in python also works on IOS and AndroidTensorflow/Caffe2 are used a lot in production especially on mobile. CNN architecturesFocuses on CNN architectures that won ImageNet competition since 2012.These architectures includes: AlexNet, VGG, GoogLeNet, and ResNet.Also we will discuss some interesting architectures as we go.The first ConvNet that was made was LeNet-5 architectures are:by Yann Lecun at 1998.Architecture are: CONV-POOL-CONV-POOL-FC-FC-FCAlexNet (2012):ConvNet that started the evolution and wins the ImageNet at 2012.Architecture are: CONV1-MAXPOOL1-NORM1-CONV2-MAXPOOL2-NORM2-CONV3-CONV4-CONV5-MAXPOOL3-FC6-FC7-FC8Contains exactly 8 layers the first 5 are Convolutional and the last 3 are fully connected layers.Some other details:First use of RELU.Norm layers but not used any more.heavy data augmentationDropout 0.5batch size 128SGD momentum 0.9Learning rate 1e-2 reduce by 10 at some iterations7 CNN ensembles!AlexNet was trained on GTX 580 GPU with only 3 GB which wasn’t enough to train in one machine so they have spread the feature maps in half. The first AlexNet was distributed!Its still used in transfer learning in a lot of tasks.Total number of parameters are 60 millionVGGNet (2014) (Oxford)Deeper network with more layers.Contains 19 layers.Won on 2014 with GoogleNet with error 7.3%Smaller filters with deeper layers.The great advantage of VGG was the insight that multiple 3 × 3 convolution in sequence can emulate the effect of larger receptive fields, for examples 5 × 5 and 7 × 7.Used the simple 3 x 3 Conv all through the network.Has a similar details in training like AlexNet. Like using momentum and dropout.在卷积神经网络中，感受野的定义是 卷积神经网络每一层输出的特征图（feature map）上的像素点在原始图像上映射的区域大小，即每一层feature的感受野都是对于原始输入图像而言的，而不是上一层的输入,但是在计算过程中，需要逐层计算该层在往上的每一层的感受野;公式 (N-1)_RF = f(N_RF, stride, ksize) = (N_RF - 1) * stride(convN) +ksize(convN)，其中，RF是感受野。N_RF和RF有点像，N代表 neighbour，指的是第n层的 a feature在n-1层的RF,显然第N层feature map在第N层的RF=1,在N-1层的RF=ksize__convN，计算RF时不需要考虑padding的影响。Feature Map的尺寸=(input_size + 2 * padding_size − ksize)/stride+1根据定义 感受野是决定某一层输出结果中一个元素所对应的输入层的区域大小这里指的是要求解的那层的一个元素也就是最初输入的out=1:rfsize = f(out, stride, ksize) = (out - 1) * stride + ksize感受野近似于用feature map为1时反推input_size ，只是不考虑paddingGoogleNet (2014)Deeper network with more layers.Contains 22 layers.It has Efficient Inception module.Only 5 million parameters! 12x less than AlexNetWon on 2014 with VGGNet with error 6.7%Inception module:内含并行操作的多种conv,将他们各自的输出在最后按depth堆叠成一个输出.Design a good local network topology (network within a network (NiN)) and then stack these modules on top of each other.It consists of:Apply parallel filter operations on the input from previous layerMultiple convs of sizes (1 x 1, 3 x 3, 5 x 5)Adds padding to maintain the sizes.Pooling operation. (Max Pooling)Adds padding to maintain the sizes.Concatenate all filter outputs together depth-wise.For example:Input for inception module is 28 x 28 x 256Then the parallel filters applied:(1 x 1), 128 filter # output shape (28,28,128)(3 x 3), 192 filter # output shape (28,28,192)(5 x 5), 96 filter # output shape (28,28,96)(3 x 3) Max pooling # output shape (28,28,256)After concatenation this will be (28,28,672)By this design -We call Naive- it has a big computation complexity.The last example will make:[1 x 1 conv, 128] ==&gt; 28 * 28 * 128 * 1 * 1 * 256 = 25 Million approx[3 x 3 conv, 192] ==&gt; 28 * 28 * 192 *3 *3 * 256 = 346 Million approx[5 x 5 conv, 96] ==&gt; 28 * 28 * 96 * 5 * 5 * 256 = 482 Million approxIn total around 854 Million operation!Solution:bottleneck layers that use 1x1 convolutions to reduce feature depth.Inspired from NiN (Network in network)So GoogleNet stacks this Inception module multiple times to get a full architecture of a network that can solve a problem without the Fully connected layers.Just to mention, it uses an average pooling layer at the end before the classification step.Full architecture:In February 2015 Batch-normalized Inception was introduced as Inception V2. Batch-normalization computes the mean and standard-deviation of all feature maps at the output of a layer, and normalizes their responses with these values.ResNet (2015) (Microsoft Research)152-layer model for ImageNet. Winner by 3.57% which is more than human level error.This is also the very first time that a network of &gt; hundred, even 1000 layers was trained.Swept all classification and detection competitions in ILSVRC’15 and COCO’15!What happens when we continue stacking deeper layers on a “plain” Convolutional neural network?The deeper model performs worse, but it’s not caused by overfitting!网络变深,准确率反而下降The learning stops performs well somehow because deeper NN are harder to optimize!网络越深，越难优化，容易出现vanish gradientThe deeper model should be able to perform at least as well as the shallower model.A solution by construction is copying the learned layers from the shallower model and setting additional layers to identity mapping.如何保证加深的网络能够学到新的知识，并保证旧的知识也保存了下来？identity mapping的存在就是这个价值。Residual block:Microsoft came with the Residual block which has this architecture:12# Instead of us trying To learn a new representation, We learn only ResidualY = (W2* RELU(W1x+b1) + b2) + XSay you have a network till a depth of N layers. You only want to add a new layer if you get something extra out of adding that layer.One way to ensure this new (N+1)th layer learns something new about your network is to also provide the input(x) without any transformation to the output of the (N+1)th layer. This essentially drives the new layer to learn something different from what the input has already encoded.这样可以驱使新的网络层学习与前N层已经学到的东西不同的内容The other advantage is such connections help in handling the Vanishing gradient problem in very deep networks.这样的结构有助于解决在很深的网络中导致的梯度消失问题With the Residual block we can now have a deep NN of any depth without the fearing that we can’t optimize the network.ResNet with a large number of layers started to use a bottleneck layer similar to the Inception bottleneck to reduce the dimensions.Resnet中包含了大量的类似inception bottleneck设计的bottlenect layer用于减少维度Full ResNet architecture:Stack residual blocks.Every residual block has two 3 x 3 conv layers.Additional conv layer at the beginning.No FC layers at the end (only FC 1000 to output classes)Periodically, double number of filters and downsample spatially using stride 2 (/2 in each dimension)Training ResNet in practice:Batch Normalization after every CONV layer.Xavier/2 initialization from He et al.SGD + Momentum (0.9)Learning rate: 0.1, divided by 10 when validation error plateausMini-batch size 256Weight decay of 1e-5No dropout used.ResNets Improvements:(2016) Identity Mappings in Deep Residual NetworksFrom the creators of ResNet.Gives better performance.(2016) Wide Residual NetworksArgues that residuals are the important factor, not depth50-layer wide ResNet outperforms 152-layer original ResNetIncreasing width instead of depth more computationally efficient (parallelizable)(2016) Deep Networks with Stochastic DepthMotivation: reduce vanishing gradients and training time through short networks during training.Randomly drop a subset of layers during each training passUse full deep network at test time.Beyond ResNets:(2017) FractalNet: Ultra-Deep Neural Networks without ResidualsArgues that key is transitioning effectively from shallow to deep and residual representations are not necessary.Trained with dropping out sub-pathsFull network at test time.(2017) Densely Connected Convolutional Networks(2017) SqueezeNet: AlexNet-level Accuracy With 50x Fewer Parameters and &lt;0.5Mb Model SizeGood for production.It is a re-hash of many concepts from ResNet and Inception, and show that after all, a better design of architecture will deliver small network sizes and parameters without needing complex compression algorithms.Conclusion:ResNet current best default.Trend towards extremely deep networksIn the last couple of years, some models all using the shortcuts like “ResNet” to eaisly flow the gradients. Recurrent Neural networksRecurrent Neural Networks RNN Models:One to manyExample: Image Captioningimage ==&gt; sequence of wordsMany to OneExample: Sentiment Classificationsequence of words ==&gt; sentimentMany to manyExample: Machine Translationseq of words in one language ==&gt; seq of words in another languageExample: Video classification on frame levelSo what is a recurrent neural network?Recurrent core cell that take an input x and that cell has an internal state that are updated each time it reads an input.The RNN block should return a vector.We can process a sequence of vectors x by applying a recurrence formula at every time step:1h[t] = fw (h[t-1], x[t]) # Where fw is some function with parameters WThe same function and the same set of parameters are used at every time step.(Vanilla) Recurrent Neural Network:12h[t] = tanh (W[h,h]*h[t-1] + W[x,h]*x[t]) # Then we save h[t]y[t] = W[h,y]*h[t]This is the simplest example of a RNN.RNN works on a sequence of related data.Recurrent NN Computational graph:h0 are initialized to zero.Gradient of W is the sum of all the W gradients that has been calculated!A many to many graph:​","categories":[{"name":"cs231n","slug":"cs231n","permalink":"http://aier02.com/categories/cs231n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"}]},{"title":"optimization","slug":"optimization","date":"2018-10-05T12:44:14.537Z","updated":"2018-10-05T15:46:13.106Z","comments":true,"path":"2018/10/05/optimization/","link":"","permalink":"http://aier02.com/2018/10/05/optimization/","excerpt":"","text":"OptimizationOptimization is the process of finding the set of parameters W that minimize the loss function,如何改变w使得损失函数不断减小 Strategy #1 random search核心思想:一次性找到使得损失函数最小的w取值貌似很难？(random search,a bad idea），但是iterative refinement直观上是可行的，故可以给予w一个random 值，然后迭代的改进，使得loss每次都比上次要小。Our strategy will be to start with random weights and iteratively refine them over time to get lower loss类似于一个戴眼罩的hiker，在多个角度下尝试往下走，直到山底。如在CIFAR-10中，hills are 30730 dimensional. Strategy #2 random local search策略一相当于随意选定某条路径前进，若根据该路径直接走到的地方更低，则选择该方向最优；而策略二相当于先随意选定某条路径，然后循环地在这个路径上进行随意的方向修改，若走到的地方更低，则进行路径的修改，直到循环结束。 Strategy #3 follow gradient不用刻意规划路线，而是要找到每一步的最优方向，即loss下降的方向gradinet，也就是当时脚下的hills的斜坡方向所谓gradient就是a generalization of slope for functions that don’t take a single number but a vector of numbers，由在所求函数对整个输入空间中的各个维度的derivative，即偏导数组成。一维导数的定义:df(x)dx=limh→0f(x+h)−f(x)h\\frac{df(x)}{dx} = \\lim_{h\\ \\to 0} \\frac{f(x + h) - f(x)}{h}​dx​​df(x)​​=​h →0​lim​​​h​​f(x+h)−f(x)​​When the functions of interest take a vector of numbers instead of a single number,(即自变量不止一个,对不同的变量进行求导) we call the derivatives partial derivatives, and the gradient is simply the vector of partial derivatives in each dimension.gradient是函数增长速率最快的方向,The gradient tells us the slope of the loss function along every dimension, which we can use to make an update。 Computing gradient两种方式:数值解和分析解 Numerical gradient实质是根据一维导数的公式进行计算，每次在输入x的一个维度上进行数值求解，即让该维度上旧的值加上指定的h(尽可能小，公式中是goes toward zero)，算得f(x+h)后再算(f(x+h)-f(x))/h，以求得在该维度上的偏导数的近似值,计算完某个维度后注意要设置回原来的输入再进行下个维度的计算.it = np.nditer(x, flags=['multi_index'], op_flags=['readwrite'])创建了一个numpy数组的迭代器，这里的flags表示对数组进行多重索引，op_flags表示迭代器对数组x可执行读写操作。print it.multi_index可以得到数组元素所有的索引(以元组形式返回)，如(0,0),(0,1)在实际应用中，计算梯度的时候常用centered difference formulaf(x+h)−f(x−h)2h\\frac{f(x+h)-f(x-h)}{2h}​2h​​f(x+h)−f(x−h)​​根据gradient，在每个维度上朝着loss funcitn增长速率最快的方向的负方向进行step_size的更新。Update in negative gradient direction. In the code above, notice that to compute W_new we are making an update in the negative direction of the gradient df since we wish our loss function to decrease, not increase.step_size的作用:the gradient tells us the direction in which the function has the steepest rate of increase, but it does not tell us how far along this direction we should step效率问题:显然对于每个维度(数组索引)进行数值求解，则对于gradient的求解是O(n)，n为w的维度，或者wijw_{ij}w​ij​​的个数；对于神经网络而言，参数个数太多，数值解扩展性太差。 Analytic gradient通过微积分进行导数的推导,得到导数确切的值，而不是近似解。求导数容易出错，所以经常讲分析解和数值解进行比较，称为gradient check。举例SVM loss function，对于单个示例xix_ix​i​​:Li=∑j≠yi[max(0,wjTxi−wyiTxi+Δ)]L_i = \\sum_{j\\neq y_i} \\left[ \\max(0, w_j^Tx_i - w_{y_i}^Tx_i + \\Delta) \\right]L​i​​=​j≠y​i​​​∑​​[max(0,w​j​T​​x​i​​−w​y​i​​​T​​x​i​​+Δ)]对于wyiw_{y_i}w​y​i​​​​,∇wyiLi=−(∑j≠yi1(wjTxi−wyiTxi+Δ&gt;0))xi\\nabla_{w_{y_i}} L_i = - \\left( \\sum_{j\\neq y_i} \\mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \\Delta &gt; 0) \\right) x_i∇​w​y​i​​​​​​L​i​​=−​⎝​⎛​​​j≠y​i​​​∑​​1(w​j​T​​x​i​​−w​y​i​​​T​​x​i​​+Δ&gt;0)​⎠​⎞​​x​i​​where 𝟙 is the indicator function that is one if the condition inside is true or zero otherwise对于wjw_jw​j​​,∇wjLi=1(wjTxi−wyiTxi+Δ&gt;0)xi\\nabla_{w_j} L_i = \\mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \\Delta &gt; 0) x_i∇​w​j​​​​L​i​​=1(w​j​T​​x​i​​−w​y​i​​​T​​x​i​​+Δ&gt;0)x​i​​Once you derive the expression for the gradient it is straight-forward to implement the expressions and use them to perform the gradient update Gradient descentthe procedure of repeatedly evaluating the gradient and then performing a parameter update is called Gradient Descent123while True: weights_grad = evaluate_gradient(loss_fun, data, weights) weights += - step_size * weights_grad # perform parameter updateMini-batch gradient descent.对于输入数据量庞大的training set，为了更新w的某个索引下的值而对庞大的data进行操作有点浪费，常用的方法是compute the gradient over batches of the training data1234while True: data_batch = sample_training_data(data, 256) # sample 256 examples weights_grad = evaluate_gradient(loss_fun, data_batch, weights) weights += - step_size * weights_grad # perform parameter update为何在一小部分的数据中更新w也是可行的？The reason this works well is that the examples in the training data are correlatedThe extreme case of this is a setting where the mini-batch contains only a single example. This process is called Stochastic Gradient Descent (SGD) (or also sometimes on-line gradient descent)比较少见 Summary两种求gradient的方法:We discussed the tradeoffs between computing the numerical and analytic gradient. The numerical gradient is simple but it is approximate and expensive to compute. The analytic gradient is exact, fast to compute but more error-prone since it requires the derivation of the gradient with math. Hence, in practice we always use the analytic gradient and then perform a gradient check, in which its implementation is compared to the numerical gradient梯度下降方法:We introduced the Gradient Descent algorithm which iteratively computes the gradient and performs a parameter update in loop总的来说优化就是通过寻找loss function下降速度最快的方向(gradient的反方向)，对w进行不断的适当幅度(learning rate)的更新，使得loss不断减少。","categories":[{"name":"cs231n","slug":"cs231n","permalink":"http://aier02.com/categories/cs231n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"},{"name":"image classification","slug":"image-classification","permalink":"http://aier02.com/tags/image-classification/"}]},{"title":"linear classification","slug":"linear_classification","date":"2018-10-03T05:31:44.756Z","updated":"2018-12-16T12:01:20.756Z","comments":true,"path":"2018/10/03/linear_classification/","link":"","permalink":"http://aier02.com/2018/10/03/linear_classification/","excerpt":"","text":"Linear classification Multiclass SVM基本形式为y=wx+b，此时的x为列向量，一列为一个样本，w的每一行为一个class的template。loss function:Multiclass Support Vector Machine (SVM) loss,SVM “wants” the correct class for each image to a have a score higher than the incorrect classes by some fixed margin Δ;Δ为超参，需要人为设定，它的存在说明多类svm关注的和普通的svm思想上是一致的，都是关注距离超平面一定范围内的误分类点，也就是间隔边界内的点，所以这里的损失函数和合页损失函数的设计是一样的；故第i张图像的损失函数为Li=∑j≠yimax(0,sj−syi+Δ)L_i = \\sum_{j\\neq y_i} \\max(0, s_j - s_{y_i} + \\Delta)L​i​​=​j≠y​i​​​∑​​max(0,s​j​​−s​y​i​​​​+Δ)注意这里的sj表示的是该图像在第j类的得分，而yi表示的是该图像的label，即只要计算其错误分类的所有分数和正确分类的分数的差值之和，当label类的得分没有大于某个非label类得分margin时，两者的差值会被算入loss中。引入regularizationR(W)=∑k∑lWk,l2R(W) = \\sum_k\\sum_l W_{k,l}^2R(W)=​k​∑​​​l​∑​​W​k,l​2​​完整的multicalss SVM loss:L = \\underbrace{ \\frac{1}{N} \\sum_i L_i }_\\text{data loss} + \\underbrace{ \\lambda R(W) }_\\text{regularization loss}扩展形式为:L=1N∑i∑j≠yi[max(0,f(xi;W)j−f(xi;W)yi+Δ)]+λ∑k∑lWk,l2L = \\frac{1}{N} \\sum_i \\sum_{j\\neq y_i} \\left[ \\max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \\Delta) \\right] + \\lambda \\sum_k\\sum_l W_{k,l}^2L=​N​​1​​​i​∑​​​j≠y​i​​​∑​​[max(0,f(x​i​​;W)​j​​−f(x​i​​;W)​y​i​​​​+Δ)]+λ​k​∑​​​l​∑​​W​k,l​2​​λ\\lambdaλ为超参，常用cross validation确定，表示模型的一种偏好。L2范数作为正则化项的好处是:The most appealing property is that penalizing large weights tends to improve generalization, because it means that no input dimension can have a very large influence on the scores all by itself,即在wx+b得分一样的情况下，L2范数的模型偏向于选择smaller and diffuse weights，使得没有哪个维度影响很大。setting delta:一般设置为1.0是安全的，在loss function中delta和lambda其实具有相同effect在tradeoff上，所以真正有意义的是对于lambda的控制与二分类的svm比较:Li=Cmax(0,1−yiwTxi)+R(W)L_i = C \\max(0, 1 - y_i w^Tx_i) + R(W)L​i​​=Cmax(0,1−y​i​​w​T​​x​i​​)+R(W)这里的yi∈{−1,1}y_i \\in \\{ -1,1 \\}y​i​​∈{−1,1} Softmax classifierf(xi;W)=Wxif(x_i; W) = W x_if(x​i​​;W)=Wx​i​​和svm保持一致，但经过softmax层用于指示概率的大小，损失函数由hinge loss变成cross-entropy lossL_i = -\\log\\left(\\frac{e^{f_{y_i}}}{ \\sum_j e^{f_j} }\\right) \\hspace{0.5in} \\text{or equivalently} \\hspace{0.5in} L_i = -f_{y_i} + \\log\\sum_j e^{f_j}fj(z)=ezj∑kezkf_j(z) = \\frac{e^{z_j}}{\\sum_k e^{z_k}}f​j​​(z)=​∑​k​​e​z​k​​​​​​e​z​j​​​​​​称为softmax function,这里的z即为wx+b，整个softmax function estimated class probabilities，即unnormalized log probabilities交叉熵:p为true distibution，q为estimated distributionH(p,q)=−∑xp(x)logq(x)H(p,q) = - \\sum_x p(x) \\log q(x)H(p,q)=−​x​∑​​p(x)logq(x)Practical issues: Numeric stability:efyi∑jefj=CefyiC∑jefj=efyi+logC∑jefj+logC\\frac{e^{f_{y_i}}}{\\sum_j e^{f_j}} = \\frac{Ce^{f_{y_i}}}{C\\sum_j e^{f_j}} = \\frac{e^{f_{y_i} + \\log C}}{\\sum_j e^{f_j + \\log C}}​∑​j​​e​f​j​​​​​​e​f​y​i​​​​​​​​=​C∑​j​​e​f​j​​​​​​Ce​f​y​i​​​​​​​​=​∑​j​​e​f​j​​+logC​​​​e​f​y​i​​​​+logC​​​​常用的设置方法是logC=−maxjfj\\log C = -\\max_j f_jlogC=−max​j​​f​j​​The Softmax classifier gets its name from the softmax function, which is used to squash the raw class scores into normalized positive values that sum to one, so that the cross-entropy loss can be applied. SVM vs. Softmax主要区别在有loss function:两者的分数向量f都是一样的，不同的在于对f的解释，svm认为f是对应种类的得分，hinge loss鼓励正确的class得分比所有错误的class score都高出一个margin；而softmax认为f是在没有标准化之前表示的是属于某个种类的log概率，并且cross entropy鼓励正确的正确分类的概率大(-log§变小)Hence, the probabilities computed by the Softmax classifier are better thought of as confidences where, similar to the SVM Further ReadingDeep Learning using Linear Support Vector Machines from Charlie Tang 2013 presents some results claiming that the L2SVM outperforms Softmax.","categories":[{"name":"cs231n","slug":"cs231n","permalink":"http://aier02.com/categories/cs231n/"}],"tags":[{"name":"notebook","slug":"notebook","permalink":"http://aier02.com/tags/notebook/"},{"name":"linear classification","slug":"linear-classification","permalink":"http://aier02.com/tags/linear-classification/"},{"name":"SVM","slug":"SVM","permalink":"http://aier02.com/tags/SVM/"}]},{"title":"pytorch cookbook U2&U3","slug":"pytorch_cookbook-U2&U3","date":"2018-10-02T08:27:32.398Z","updated":"2018-11-07T07:21:58.471Z","comments":true,"path":"2018/10/02/pytorch_cookbook-U2&U3/","link":"","permalink":"http://aier02.com/2018/10/02/pytorch_cookbook-U2&U3/","excerpt":"","text":"pytorch-cookbook 第二章函数名后带下划线会修改函数本身如y.add_(x)会直接修改ypytorch的tensor和numpy的对象共享内存，两者同时改变;对于tensor不支持的操作，可以先转为numpy进行操作在转为tensor（tensor支持gpu）1234a=t.ones(5)b = a.numpy() # Tensor -&gt; Numpya = np.ones(5)b = t.from_numpy(a) # Numpy-&gt;Tensortensor[idx]得到的为0-dim的tensor，scalar.item()获取tensor的单个元素对象t.Tensor(5,3)创建5行3列的tensor，t.tensor([3,4])创建包含3，4两个元素的tensort.tensor()会进行数据拷贝，新的tensor和旧的不共享内存，而torch.from_numpy（）或者tensor.detach()则相反使用gpu123device = t.device(&quot;cuda:0&quot; if t.cuda.is_available() else &quot;cpu&quot;)x = x.to(device)y = y.to(device)autograd: 自动微分;要想使得Tensor使用autograd功能，只需要设置tensor.requries_grad=True.如：x = t.ones(2, 2, requires_grad=True)注意：grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以反向传播之前需把梯度清零。# 以下划线结束的函数是inplace操作，会修改自身的值，就像add__1x.grad.data.zero_()一起求导的过程示例123456x=t.ones(2,2,requires_grad=True)#生成tensory=x.sum()#定义表达式y.grad_fn#查看求导函数y.backward()#back propagationx.grad#查看y对x的导数x.grad.data_zero_()#清空导数缓存空间nerual network的定义主要是对torch.nn模块的使用,定义网络时，需要继承nn.Module，并实现它的forward方法，把网络中具有可学习参数的层放在构造函数__init__中。如果某一层(如ReLU)不具有可学习的参数，则既可以放在构造函数中，也可以不放，但建议不放在其中，而在forward中使用nn.functional代替,forwar的输入和输出都是tensor,input = t.randn(1, 1, 32, 32),需要注意的是，torch.nn只支持mini-batches，不支持一次只输入一个样本，即一次必须是一个batch。但如果只想输入一个样本，则用 input.unsqueeze(0)将batch_size设为１,size形式为nSamples x nChannels x height x weight123456789101112131415161718192021222324252627282930import torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): # nn.Module子类的函数必须在构造函数中执行父类的构造函数 # 下式等价于nn.Module.__init__(self) super(Net, self).__init__() # 卷积层 &apos;1&apos;表示输入图片为单通道, &apos;6&apos;表示输出通道数，&apos;5&apos;表示卷积核为5*5 self.conv1 = nn.Conv2d(1, 6, 5) # 卷积层 self.conv2 = nn.Conv2d(6, 16, 5) # 仿射层/全连接层，y = Wx + b self.fc1 = nn.Linear(16*5*5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): # 卷积 -&gt; 激活 -&gt; 池化 x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) x = F.max_pool2d(F.relu(self.conv2(x)), 2) # reshape，‘-1’表示自适应 x = x.view(x.size()[0], -1) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return xnet = Net()print(net)conv layer主要特征是局部连接和权重共享局部连接：每个神经元仅与输入神经元的一块区域连接，这块局部区域称作感受野（receptive field）。在图像卷积操作中，即神经元在空间维度（spatial dimension，即上图示例H和W所在的平面）是局部连接，但在深度上是全部连接。对于二维图像本身而言，也是局部像素关联较强。这种局部连接保证了学习后的过滤器能够对于局部的输入特征有最强的响应。局部连接的思想，也是受启发于生物学里面的视觉系统结构，视觉皮层的神经元就是局部接受信息的。*权重共享：计算同一个深度切片的神经元时采用的滤波器是共享的。例上图中计算o[:,:,0]的每个每个神经元的滤波器均相同，都为W0，这样可以很大程度上减少参数。共享权重在一定程度上讲是有意义的，例如图片的底层边缘特征与特征在图中的具体位置无关。但是在一些场景中是无意的，比如输入的图片是人脸，眼睛和头发位于不同的位置，希望在不同的位置学到不同的特征 。请注意权重只是对于同一深度切片的神经元是共享的，在卷积层，通常采用多组卷积核提取不同特征，即对应不同深度切片的特征，不同深度切片的神经元权重是不共享。另外，偏重对同一深度切片的所有神经元都是共享的。池化是非线性下采样的一种形式，主要作用是通过减少网络的参数来减小计算量，并且能够在一定程度上控制过拟合。网络的可学习参数通过net.parameters()返回,net.named_parameters可同时返回可学习的参数及名称。nn.MSELoss()实现均方误差，nn.CrossEntropyLoss()实现交叉熵损失优化器更新参数1234567891011121314151617 import torch.optim as optim #新建一个优化器，指定要调整的参数和学习率optimizer = optim.SGD(net.parameters(), lr = 0.01) # 在训练过程中 # 先梯度清零(与net.zero_grad()效果一样)optimizer.zero_grad() # 计算损失output = net(input)loss = criterion(output, target) #反向传播loss.backward() #更新参数optimizer.step()数据加载和预处理：使用torchvision示例：下面我们来尝试实现对CIFAR-10数据集的分类，步骤如下:使用torchvision加载并预处理CIFAR-10数据集,得到dataset和dataloader定义网络,继承nn.Module,init中写入可学习的参数函数，forward定义好前向传播的过程定义损失函数和优化器，criterion和optimizer训练网络并更新网络参数，在每个ephco中加载数据，传入net，算loss，loss.backward，optimizer.step测试网络定义对数据的预处理:将两种转化合并一起；ToTensor()将shape为(H, W, C)的nump.ndarray或img转为shape为(C, H, W)的tensor，其将每一个数值归一化到[0,1]，其归一化方法比较简单，直接除以255即可，加入normalize则其作用就是先将输入归一化到(0,1)，再使用公式”(x-mean)/std”，将每个元素分布到(-1,1),函数normalize（std,mean）1234transform = transforms.Compose([ transforms.ToTensor(), # 转为Tensor transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)), # 归一化 ])Dataset对象是一个数据集，可以按下标访问，返回形如(data, label)的数据。Dataloader是一个可迭代的对象，它将dataset返回的每一条数据拼接成一个batch，并提供多线程加速优化和数据打乱等操作。当程序对dataset的所有数据遍历完一遍之后，相应的对Dataloader也完成了一次迭代，先定义好dataset，然后定义dataloader对指定的dataset进行操作123456789101112 # 训练集trainset = tv.datasets.CIFAR10( root=&apos;/home/cy/tmp/data/&apos;, train=True, download=True, transform=transform)trainloader = t.utils.data.DataLoader( trainset, batch_size=4, shuffle=True, num_workers=2)进行normaliza的必要性：每个样本图像减去数据集图像的均值后除以方差，保证了所有图像的分布相似，使得model训练的时候更快的收敛.训练网络的示例12345678910111213141516171819202122232425262728t.set_num_threads(8)for epoch in range(2): running_loss = 0.0 for i, data in enumerate(trainloader, 0): # 输入数据 inputs, labels = data # 梯度清零 optimizer.zero_grad() # forward + backward outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() # 更新参数 optimizer.step() # 打印log信息 # loss 是一个scalar,需要使用loss.item()来获取数值，不能使用loss[0] running_loss += loss.item() if i % 2000 == 1999: # 每2000个batch打印一下训练状态 print(&apos;[%d, %5d] loss: %.3f&apos; \\ % (epoch+1, i+1, running_loss / 2000)) running_loss = 0.0print(&apos;Finished Training&apos;) 第三章表3-1: 常见新建tensor的方法函数功能Tensor(*sizes)基础构造函数tensor(data,)类似np.array的构造函数ones(*sizes)全1Tensorzeros(*sizes)全0Tensoreye(*sizes)对角线为1，其他为0arange(s,e,step从s到e，步长为steplinspace(s,e,steps)从s到e，均匀切分成steps份rand/randn(*sizes)均匀/标准分布normal(mean,std)/uniform(from,to)正态分布/均匀分布randperm(m)随机排列除了tensor.size()，还可以利用tensor.shape直接查看tensor的形状，tensor.shape等价于tensor.size()tensor = t.Tensor(1,2)创建了一个size为【1，2】的张量vector = t.tensor([1, 2])创建了一个值为（1，2）的向量，size为2scalar = t.tensor(3.14159) 创建了一个值为3.14159的标量，size为【】,区别于size【0】，empty_tensor = t.tensor([])，size存在即为tensor,否则为scalar通过tensor.view方法可以调整tensor的形状，但必须保证调整前后元素总数一致。view不会修改自身的数据，返回的新tensor与源tensor共享内存，也即更改其中的一个，另外一个也会跟着改变。b = a.view(-1, 3)当某一维为-1的时候，会自动计算它的大小,torch.squeeze() 这个函数主要对数据的维度进行压缩，去掉维数为1的的维度，比如是一行或者一列这种，一个一行三列（1,3）的数去掉第一个维数为一的维度之后就变成（3）行。squeeze(a)就是将a中所有为1的维度删掉。不为1的维度没有影响。a.squeeze(N) 就是去掉a中指定的维数为一的维度。还有一种形式就是b=torch.squeeze(a，N) a中去掉指定的定的维数为一的维度。torch.unsqueeze()这个函数主要是对数据维度进行扩充。给指定位置加上维数为一的维度，比如原本有个三行的数据（3），在0的位置加了一维就变成一行三列（1,3）。a.unsqueeze(N) 就是在a中指定位置N加上一个维数为1的维度。还有一种形式就是b=torch.unsqueeze(a，N) a就是在a中指定位置N加上一个维数为1的维度resize是另一种可用来调整size的方法，但与view不同，它可以修改tensor的大小。如果新大小超过了原大小，会自动分配新的内存空间，而如果新大小小于原大小，则之前的数据依旧会被保存，当再次扩展时其值为当时缩小保存的值tensor的索引操作和tensor共享内存，即更改其中一个，另一个也会更改。a[None]:None类似于np.newaxis, 为a新增了一个轴；等价于a.view(1, a.shape[0], a.shape[1])a &gt; 1 # 返回一个ByteTensor,即满足条件的位置值为1，否则为0对tensor的任何索引操作仍是一个tensor，想要获取标准的python对象数值，需要调用tensor.item(), 这个方法只对包含一个元素的tensor适用","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://aier02.com/categories/pytorch/"}],"tags":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://aier02.com/tags/basic-knowledge/"},{"name":"pytorch cookbook","slug":"pytorch-cookbook","permalink":"http://aier02.com/tags/pytorch-cookbook/"}]},{"title":"first time in Kaggle-summary","slug":"rsna_summary","date":"2018-10-01T16:08:39.573Z","updated":"2018-12-17T01:59:12.360Z","comments":true,"path":"2018/10/02/rsna_summary/","link":"","permalink":"http://aier02.com/2018/10/02/rsna_summary/","excerpt":"","text":"项目存在的问题和解决方案 RSNA 如何开始比赛完全是新手，很早以前就有学长介绍过kaggle，最近看完了cs231n，然后打算试试手，但是一开始并不知道应该做什么，于是就上知乎直接搜了如何打kaggle比赛，找到的很多的都是ml的，但是个人更喜欢cv，添加了关键词后，找到了一篇和我类似经历的blog，知道了kaggle比赛到底是什么，他的每个板块表示的是什么，常用的步骤是什么，有什么需要注意的（这个时候开始意识到我没有gpu，这点必定是后期的瓶颈） 选择平台没有gpu怎么办，没有资源只能去租用云平台跑model，开头抱有侥幸心理，有没有什么免费的平台呢，一开始找到的是google 的colab，听说是免费的，然后我就直接尝试使用，跑了一下mnist的基本模型发现经常自动断开连接，而且他给的免费的硬盘空间只有15g，当时我首先打算打的比赛其实是有关air ship的detection比赛。果然天底下没有免费的午餐，只能另找平台，后来在知乎上看到不少人推荐极客云，他自动帮你搭建好了深度学习的环境，（其实这是个坑，创建的dl环境是不能直接操作整个系统的，任何系统的指令都无法操作，这使得我后来无法进行端口的查询，visdom启动的时候总是提示端口被占用），运行的速度和价钱的确很吸引人 EDA什么是lung opacities，什么是pneumonia，他们两者有什么关系么？由于缺乏领域知识，得益于知乎，我直接奔向了discussion和kernel，果然找到了一篇名为what r lung opacities的kernel，这篇文章由一个具备radiologist领域知识的kaggler提供，他直接介绍了怎么看chest x-ray，黑色的为air，白色的为bone，grey为tissue或者fluid，这个kernel对于我整个项目影响最大，他补充了我xray的领域知识。做eda主要是看各个文件中的数量、样本中是否存在重复，是否有缺失，class_label.csv文件中有多少中不同的class，各自的数量如何，他与train数据集是否一一对应，open（）函数，创建一个reader，next跳过header之后就循环读取reader实现按行读取数据；也可用pd.read_csv实现，value_counts()统计重复的次数，groupby（keyword）可以根据keyword分组；主要用到了matplotlib.pyplot，numpy，pandas，pydicom，glob进行数据可视化 detection？还是segmentation？诚然我一开始看到官方的比赛介绍的时候，我主观上是认为要根据dicom图像提供的病人的个人信息以及图像中的信息进行classification，根据我个人对于部分pneumonia的xray的观察，以及提供的数据集中的bboxes的信息和之前提到的那篇kernel的引导，本次比赛更多的是做能指示pneumonia的lung opacities，而且明显是难以完全sgment出来的（opacities有一种是模糊了心脏和lung的边界。于是决定做detection 数据准备前期所做的数据准备，我的想法是直接把pneumonia的bbox的x,y,w,h装入内存，很明显这中做法有一定的风险，遇到内存不足恐怕直接爆了，后期我选择了使用npy文件先预先读取train_lable的信息，然后每次使用的时候再进行读取，这样的做法个人认为可以避免每次训练的时候进行pydicom数据的转换，也能减少内存的使用，后果用了更多的磁盘空间，而且每次读取npy文件都是存在时间成本的。而且有个严重的问题，就是后期如何做数据增强，是对image进行操作，pydicom.dcmread()和cv2.imread读都是hwc，而且是BGR上的0-255为了使后期进行读取方便，我把使用sitk.ReadImage（dcm）将所有的dcm图像转为png格式，sitk.GetArrayFromImage返回的是（hwc），同时存储患有肺炎的图像的numpy数组和bbox的位置信息（ymin,xmin,ymax,xmax），以npy文件的格式保存，实际上在这次操作中图片都是单通道的，而且都是1024*1024的。然后通过对patientid进行shuffle，创建train和validation，大概9:1 数据增强经过eda后，lung opacities，no lung opacities/not normal,normal,比例是1:1:1，把lung opacities作为positive，则dataset中存在样例不平衡，考虑进行图像的增强，旋转，平移，亮度改变之类的，由于是x-ray图像，考虑进行图像的仿射变换，但是旋转会涉及bbox的改变，因为之前在数字图像课程实验中学过仿射变换（旋转，缩放，平移）然后就直接实现了rotate_img_bbox(img, bboxes, degree=-45, scale=1.)，mat = cv2.getRotationMatrix2D(center,angle=degree,scale=scale) #affine matrix，仿射矩阵为（2，3）的矩阵，以水平进行划分，前（2，2）子矩阵为线性变换矩阵，（2，1）子矩阵为平移矩阵，用标量的形式来看就是ax+b；T=M【x,y,1】,对原来的bbox的四条边的四个中点进行相同的矩阵变化，然后合并为一个矩阵，表示一个仿射后的矩阵，矩形边框（Bounding Rectangle）是说，用一个最小的矩形，把找到的形状包起来。还有一个带旋转的矩形，面积会更小，即使用rx, ry, rw, rh = cv2.boundingRect(concat)得到摆正后的经过仿射变换的新的bbox，整个图像的变换out_image = cv2.warpAffine(img,mat,(width,height))做各种变换的时候由于数据集较大，而且操作多，经常出现等待时间较长的情况，缺乏可视化，不能确定是完成了操作还是仍然在等待，后来在循环中使用了tqdm进行进度条的显示，可视化了进程的进度。 准备dataset创建类generator(keras.utils.Sequence)，实现的函数分别有内置init()，初始化文件夹路径，文件名，bboxing box，batch_size=32,image_size=256(原图为1024)，shuffle，augment，predict为三者为真还是假内置len（），返回filenames中数据量的大小内置getitem（），以batchz_size为数据单位，根据index确定数据的位置，当predict为真时，返回对应文件名的图像和文件名；否则，返回对应文件名的img图像和msk，注意msks即为bboxes的列表内置load（），通过filename确定patientid，然后读取npy文件获取img_array和bboxes列表（每一项为对应图片的bbox的ymin,xmin,ymax,xmax），创建和img等大小的全0msk，根据npy中的‘bboxes’项将对应的标注框区域设置为1；然后resize图片，特别注意由于训练的时候进行的是batch_train,所以对于img和msk都必须添加一个dimension，作为训练的维度内置loadpredict（），基本操作和load函数一致，不同在与该函数不用获取bboxes信息 搭建神经网络create_downsample(channels, inputs)下采样函数，channels指示filter的大小，inputs指示images，依次使用的是keras.layers.BN(momentum=0.9)-&gt;leakyrelu-&gt;conv2d(padding=same)-&gt;maxpool2d。padding：补0策略，为“valid”, “same” 。“valid”代表只进行有效的卷积，即对边界数据不处理。“same”代表保留边界处的卷积结果，通常会导致输出shape与输入shape相同create_resblock(channels, inputs)resblock函数，一个resblock包含了BN-&gt;LEAKYRELU-&gt;CONV2D-&gt;BN-&gt;LEAKYRELU-&gt;CON2D-&gt;add([x, inputs])(channels用于conv层中filters的数目，即输出的维度，kernel_size指定filter的大小)create_network(input_size, channels, n_blocks=2, depth=4)搭建整个网络，inputs = keras.Input(shape=(input_size, input_size, 1))对输入进行规范化-&gt;conv2d-&gt;创建depth层结构，每个结构中包括了一个downsample和n_block个resblock-&gt;ouput layer依次为BN-&gt;LEAKYRELU-&gt;CONV2D-&gt;UpSampling2D(2**depth)(x)-&gt;将input和output包装为一个model即model = keras.Model(inputs=inputs, outputs=outputs) Resnet背景:随着网络的加深，出现了训练集准确率下降的现象，排除overfitting，针对该问题提出了resnet，以允许实现尽可能地加深网络resnet中提出了两种mapping，identity mapping 和 residual mapping，输出为y=F(x)+x,显然x为前者，F(x)为后者；理论上，对于“随着网络加深，准确率下降”的问题，Resnet提供了两种选择方式，也就是identity mapping和residual mapping，如果网络已经到达最优，继续加深网络，residual mapping将被push为0，只剩下identity mapping，这样理论上网络一直处于最优状态了，网络的性能也就不会随着深度增加而降低了。即真正学习的是残差，而形式上y保证了不会出现网络加深而经验误差增大的现象在resnet中加入1*1的conv layer就是bottleneck layer，目的是为了降维，降低计算量和参数的数目，最后又升维是为了保持和输入x的dimensions一致 Batch NormalizationBatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。(IID独立同分布假设，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。然后提出了BatchNorm的基本思想：能不能让每个隐层节点的激活输入分布固定下来呢？这样就避免了“Internal Covariate Shift”问题了。启发式思考：对输入图像进行白化（Whiten）操作的话——所谓白化，就是对输入数据分布变换到0均值，单位方差的正态分布——那么神经网络会较快收敛；BN所做的可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作简而言之，对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛加快。将输入x的分布强制转换到均值为0，方差为1的正态分布。经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点①不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等 定义loss function定义iou损失函数:iou_loss(y_true, y_pred),这里的label(即y)是mask，即bboxes为1的0-1图像，intersection = tf.reduce_sum(y_true * y_pred)求的共同区域的1的个数，score = (intersection + 1.) / (tf.reduce_sum(y_true) + tf.reduce_sum(y_pred) - intersection + 1.)，注意+1.是为了保证score不为0，公式为inserction/union。reduce_sum返回该矩阵所有元素之和合并损失函数:0.5 * keras.losses.binary_crossentropy(y_true, y_pred) + 0.5 * iou_loss(y_true, y_pred)，binary_crossentropy为对数损失函数损失函数是训练的关键，他表达了模型的目标，通过求原图像经过resnet后的feature map和图像的label，即bboxes的iou，使用adam进行优化，使得网络参数朝iou减少的方向进行更新。 训练参数的设置定义tf.metric算子，即评估指标算子，用于计算accuracymodel.compile(optimizer=‘adam’,loss=iou_bce_loss,metrics=[‘accuracy’, mean_iou])指定优化器，损失函数和accuracy初始化lr=0.01，epoch=25，lr的更新策略:lrx(np.cos(np.pi*x/epochs)+1.)/2,x为动态变化的epochkeras.callbacks.LearningRateScheduler(schedule)该回调函数是用于动态设置学习率，其中schedule函数以epoch号为参数（从0算起的整数），返回一个新学习率（浮点数） 创建train和validation generator指定图片文件夹:folder = ‘./input/stage_1_train_png’训练生成器:train_gen = generator(folder, train_filenames, pneumonia_locations, batch_size=32, image_size=256, shuffle=True, augment=True, predict=False)测试生成器:valid_gen = generator(folder, valid_filenames, pneumonia_locations, batch_size=32, image_size=256, shuffle=False, predict=False) 训练模型history = model.fit_generator(train_gen, validation_data=valid_gen, callbacks=[learning_rate], epochs=25, workers=4, use_multiprocessing=True)用于指定callback内容，即learning rate，训练集，验证集，epoch数量，线程数量 测试模型创建测试数据生成器:test_gen = generator(folder, test_filenames, None, batch_size=25, image_size=256, shuffle=False, predict=True)threshold predicted mask,pred中大于0.5才为maskcomp = pred[:, :, 0] &gt; 0.5apply connected componentscomp = measure.label(comp),measure.label作用是给comp标记连通区域，用于确定不同的bbox，measure.regionprops(comp)获取comp的不同连通区域，返回的region列表，每一个分别为ymin,xmin,ymax,xmax计算置信度proxy for confidence score:conf = np.mean(pred[y:y+height, x:x+width]) 提交结果保存结果到csv文件中:以字典的形式保存到csv文件中save dictionary as csv filesub = pd.DataFrame.from_dict(submission_dict,orient=‘index’)指定索引名称:sub.index.names = [‘patientId’]指定列名:sub.columns = [‘PredictionString’]写入指定目录文件:sub.to_csv(’/input/submission.csv’)","categories":[{"name":"Kaggle","slug":"Kaggle","permalink":"http://aier02.com/categories/Kaggle/"}],"tags":[{"name":"segmentation","slug":"segmentation","permalink":"http://aier02.com/tags/segmentation/"},{"name":"keras","slug":"keras","permalink":"http://aier02.com/tags/keras/"},{"name":"ResNet","slug":"ResNet","permalink":"http://aier02.com/tags/ResNet/"},{"name":"jikecloud","slug":"jikecloud","permalink":"http://aier02.com/tags/jikecloud/"}]},{"title":"python rubbish collection","slug":"python_rubbish_collection","date":"2018-09-28T07:32:02.260Z","updated":"2018-10-03T08:08:16.164Z","comments":true,"path":"2018/09/28/python_rubbish_collection/","link":"","permalink":"http://aier02.com/2018/09/28/python_rubbish_collection/","excerpt":"","text":"python垃圾回收机制 引用计数每个对象维护一个ob_ref字段，每次被别的对象引用的ob_ref加1，若引用失效，则减1，当ob_ref为0则该对象被回收，占用的内存空间被释放。但是该方法不能解决循环引用问题，即两个对象相互引用，当他们的外部引用都失效时，ob_ref仍为1，非零，但是他们实质是要被回收的，而python却不能将其回收 标记清除对活动对象进行标记，将非活动对象进行回收。对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 分代回收根据对象存活时间的不同对内存进行了划分，时间由短到长分别划分为年轻代，中年代，老年代，新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。","categories":[{"name":"python","slug":"python","permalink":"http://aier02.com/categories/python/"}],"tags":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://aier02.com/tags/basic-knowledge/"}]},{"title":"faster RCNN","slug":"faster_RCNN","date":"2018-09-18T10:55:07.479Z","updated":"2018-10-03T08:08:10.513Z","comments":true,"path":"2018/09/18/faster_RCNN/","link":"","permalink":"http://aier02.com/2018/09/18/faster_RCNN/","excerpt":"","text":"faster RCNN感受野：在卷积神经网络CNN中，决定某一层输出结果中一个元素所对应的输入层的区域大小，被称作感受野receptive fieldfatal error: numpy/arrayobject.h: No such file or directory”​这个错误的出现可以如下解决，将setup.py内容加入一条include_dirs=[numpy.get_include()]​就可以了。示例setup.py文件如下：from distutils.core import setupfrom distutils.extension import Extensionfrom Cython.Distutils import build_extimport numpy as npext_modules=[Extension(“test03”,[“test03.pyx”])]setup(name=‘gravity_cy’,cmdclass={‘build_ext’:build_ext},include_dirs = [np.get_include()],ext_modules=ext_modules) 主要问题是要指定numpy的路径过程记录：1）下载faster-rcnn的预训练模型并在demo中进行调试2）运行python misc/convert_caffe_pretrain.py把预训练的vgg16下载并保存到checkpoint中，作为cnn提取器3）","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://aier02.com/categories/pytorch/"}],"tags":[{"name":"CNN","slug":"CNN","permalink":"http://aier02.com/tags/CNN/"}]},{"title":"analysis kernel demo","slug":"analysis_kernel_demo","date":"2018-09-18T10:55:03.519Z","updated":"2018-10-30T02:57:12.890Z","comments":true,"path":"2018/09/18/analysis_kernel_demo/","link":"","permalink":"http://aier02.com/2018/09/18/analysis_kernel_demo/","excerpt":"","text":"analysis kernel demoBatchNormalization层：该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1BNleakyRelu层,大于0为x，小于0为ax(a常为0.01)pytorch自定义dataset和dataloadertorch.utils.data.Dataset是表示数据集的抽象类。您自定义的数据集应该继承Dataset并重写以下方法：len使用len(dataset)将返回数据集的大小。getitem 支持索引，dataset[i]可以获取第i个样本让我们为我们的人脸标记点数据集创建一个数据集类。我们将在init中读取csv，而将在getitem存放读取图片的任务。因为所有的图像不是一次性存储在内存中，而是根据需要进行读取，这样可以高效的使用内存。123456789101112131415class CustomDataset(data.Dataset):#需要继承data.Dataset def __init__(self): # TODO # 1. Initialize file path or list of file names. pass def __getitem__(self, index): # TODO # 1. Read one data from file (e.g. using numpy.fromfile, PIL.Image.open). # 2. Preprocess the data (e.g. torchvision.Transform). # 3. Return a data pair (e.g. image and label). #这里需要注意的是，第一步：read one data，是一个data pass def __len__(self): # You should change 0 to the total size of your dataset. return 0将numpy ndarry转为tensor：123456789101112class ToTensor(object): \"\"\"Convert ndarrays in sample to Tensors.\"\"\" def __call__(self, sample): image, landmarks = sample['image'], sample['landmarks'] # swap color axis because # numpy image: H x W x C # torch image: C X H X W image = image.transpose((2, 0, 1)) return &#123;'image': torch.from_numpy(image), 'landmarks': torch.from_numpy(landmarks)&#125;","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://aier02.com/categories/pytorch/"}],"tags":[{"name":"demo","slug":"demo","permalink":"http://aier02.com/tags/demo/"}]},{"title":"first time in Kaggle-preparation","slug":"rsna_pneumonia_detection","date":"2018-09-06T09:08:00.932Z","updated":"2018-10-03T08:15:40.619Z","comments":true,"path":"2018/09/06/rsna_pneumonia_detection/","link":"","permalink":"http://aier02.com/2018/09/06/rsna_pneumonia_detection/","excerpt":"","text":"Question descriptionIn this competition, you’re challenged to build an algorithm to detect a visual signal for pneumonia in medical images. Specifically, your algorithm needs to automatically locate lung opacities on chest radiographs.(CXR)胸部X线片上肺部阴影的定位以跟踪可能的肺炎病况They see the potential for ML to automate initial detection (imaging screening) of potential pneumonia cases in order to prioritize and expedite their review.But the title “Pneumonia Detection” for the competition is misleading because you actually have to do “Lung Opacities Detection”, and lung opacities are not the same as pneumonia. Lung opacities are vague, fuzzy clouds of white in the darkness of the lungs, which makes detecting them a real challenge.-from a kernal如何确认x照片中的阴影？ Basic informationin CXR:black-air;white-bones;grey-fluid or tissueUsually the lungs are full of air. When someone has pneumonia, the air in the lungs is replaced by other material - fluids, bacteria, immune system cells, etc. That’s why areas of opacities are areas that are grey but should be more black.(找出原来是黑但是变灰了的区域As you can see, lung opacities are not homogenoues and they do not have a clear center or clear boundaries. I don’t think you can properly segment opacities out of the entire picture because there are no clear boundries.-直接找阴影貌似很难，可以先segment lungsin fact, there was only a moderate level of agreement between radiologists about the presence of infiltrates, which are opacities by definition预测任务为病人的dcm图像找到lung opacities,以bbox的形式给出，在submission_file中，一张图片中只能有一条bbox信息，每4个信息项为一个bbox，即(x,y,weight,height) Difficultiesthere is a mass of tissue surrounding the lungs and between the lungs. These areas contain skin, muscles, fat, bones, and also the heart and big blood vessels. That translates into a lot of information on the chest radiograph that is not useful for this competition.阴影有多种，怎样的阴影才和肺炎相关The main difference in the types of opacities between these two patients is the borders and the shape of the opacity, Patient 3 has multiple round and clearly defined opacities. Patient 2 has this poorly defined haziness which obscures the margins of the lungs and heart. This haziness is termed consolidation.Exclude: obvious mass(es), nodule(s), lobar collapse, linear atelectasis要找的阴影是模糊的，难懂的，不明显的In the cases labeled Not Normal/No Lung Opacity, no lung opacity refers to no opacity suspicious for pneumonia. 在数据集中，不正常/没有肺部阴影，是指没有与肺炎相关的阴影，但会有与其他病症相关的阴影，故是不正常。两种肺炎阴影：Ground-Glass Opacities；Consolidations前者We can see that the lungs are “whiter” than they should be, but we can see most of the borders of the lungs and hear后者There are fuzzy areas in the lungs and the borders of the lungs and heart cannot be seen.玻璃粉状的阴影不会影响心脏和肺部的边界，而合并类的阴影会模糊两者的边界预测pneumoni和opacities应该独立预测？lung opacities并不是是pneumonia的充要条件实际上该比赛为Lung Opacities Detectio，而不是Pneumonia Detection exprolatory data analysisstage_1_detailed_class_info里面包括了3种class，共有28989条记录，每条信息为patientid：class，标注了病人id对应的正常、不正常/不是肺炎，肺炎3种情况stage_1_train_labels记录了bbox的位置，同样有28989条记录，每条记录分别是patientid：x,y,width,height,target;x,y表示bbox的左上角的坐标，width是宽度，即x的范围，height是高度，即y的范围，target=0表示没有肺炎，=1表示有肺炎，对应class_info，normal则bbox信息empty，target=0；No Lung Opacity / Not Normal则bbox信息empty，target=0；因此lung opacities in data is associated with pneumonia；lung opacities 则包含了bbox的信息同时target=1注意数据集存在一名病人对应多条记录的情况，并不是有28989名病人，经过eda可知存在25684名病人（patientid）(training data 中有25684张dcm)实际上因为bbox信息表是一条记录只能表示一个bbox，故存在一个病人的cxr中有多个bbox，而class表和label表相一致，所以保持对应关系class存在重复数据训练集中dcm文件不只是image，还有meta information，如sex，age等，是否需要添加此类属性，从而考虑相关的内容进行判断？patientId - A patientId. Each patientId corresponds to a unique image.x_ - the upper-left x coordinate of the bounding box.y_ - the upper-left y coordinate of the bounding box.width_ - the width of the bounding box.height_ - the height of the bounding box.Target_ - the binary Target, indicating whether this sample has evidence of pneumonia.No Lung Opacity / Not Normal and Normal have together the same percent (69.077%) as the percent of missing values for target window in class details information.显然存在正样本偏少的情况，需要做数据增强，过采样？角度偏转？ models ChexNetThe CheXNet algorithm is a 121-layer deep 2D Convolutional Neural Network; a Densenet after Huang &amp; Liu. The Densenet’s multiple residual connections reduce parameters and training time, allowing a deeper, more powerful model. The model accepts a vectorized two-dimensional image of size 224 pixels by 224 pixels.CheXNet is a 121-layer Dense Convolutional Network (DenseNet) (Huang et al., 2016) trained on the ChestX-ray 14 dataset. DenseNets improve flow of information and gradients through the network, making the optimization of very deep networks tractable. We replace the final fully connected layer with one that has a single output, after which we apply a sigmoid nonlinearity. The weights of the network are initialized with weights from a model pretrained on ImageNet (Deng et al., 2009). The network is trained end-to-end using Adam with standard parameters (ß1 = 0.9 and ß2 = 0.999) (Kingma &amp; Ba, 2014). We train the model using minibatches of size 16. We use an initial learning rate of 0.001 that is decayed by a factor of 10 each time the validation loss plateaus after an epoch, and pick the model with the lowest validation loss.","categories":[{"name":"Kaggle","slug":"Kaggle","permalink":"http://aier02.com/categories/Kaggle/"}],"tags":[{"name":"segmentation","slug":"segmentation","permalink":"http://aier02.com/tags/segmentation/"},{"name":"chest X-ray","slug":"chest-X-ray","permalink":"http://aier02.com/tags/chest-X-ray/"},{"name":"ChexNet","slug":"ChexNet","permalink":"http://aier02.com/tags/ChexNet/"},{"name":"EDA","slug":"EDA","permalink":"http://aier02.com/tags/EDA/"}]},{"title":"experience from a Kaggler","slug":"kaggle_expericence","date":"2018-09-05T02:19:10.278Z","updated":"2018-10-03T08:08:35.464Z","comments":true,"path":"2018/09/05/kaggle_expericence/","link":"","permalink":"http://aier02.com/2018/09/05/kaggle_expericence/","excerpt":"","text":"kaggle比赛步骤-经验1.仔细阅读比赛介绍和数据描述；2.查找相似的Kaggle比赛。作为一个接触不久的Kaggler，我已经完成对所有Kaggle比赛基本分析的收集；3.研究相似比赛的解决方案；4.阅读有关论文，以确保不错过该领域的最新进展；5.分析数据，并构建可靠的交叉验证结果；6.数据预处理、特征工程和模型训练。7.结果分析，包括如预测分布、错误分析和困难样本等；8.根据分析来改进模型或设计新模型；9.基于数据分析和结果分析来设计模型以增加多样性或解决困难样本；10.模型集成；11.必要时返回到前面的某个步骤。Q：你觉得，赢得比赛的关键是什么？可靠的验证方式，借鉴其他比赛并阅读相关论文，以及良好的自制力和心理素质。Q：你认为你最具竞争力的比赛技巧或方法是什么？我认为应该是在比赛开始时准备解决方案的文档。我会强迫自己写出一份清单，包括面临的挑战、应该阅读的解决方案和论文、可能的风险、可用的验证方式、可能的数据增强方法以及增加模型多样性的方式。而且，我不断更新这个文档。幸运地，这些文档为我后面在很多比赛中取得不错成绩提供了支持","categories":[{"name":"Kaggle","slug":"Kaggle","permalink":"http://aier02.com/categories/Kaggle/"}],"tags":[{"name":"experience","slug":"experience","permalink":"http://aier02.com/tags/experience/"}]},{"title":"a failed experience in Kaggle","slug":"airbus_ship_detection","date":"2018-09-05T02:18:30.433Z","updated":"2018-10-03T08:08:00.121Z","comments":true,"path":"2018/09/05/airbus_ship_detection/","link":"","permalink":"http://aier02.com/2018/09/05/airbus_ship_detection/","excerpt":"","text":"airbus-ship-detection challenge 问题描述：从卫星图像中找到ships，并用bbox分割出来 难点所在并不是所有图片都有ships在图片中ships的大小不一致图像分割不允许存在部分重叠，但数据集中的ships当两者直接相邻时，存在轻微的overlap，重叠部分将会被作为背景而移除部分带有人工标注的图片中的bbox可能存在边界像素的丢失train-ship-segmentations.csv提供了人工标注的bbox作为训练的数据图片，其中bbox以run-length encoding 表示。数据集很大，需要用到gpu，训练模型可能要几天时间run-length-encoding评价方式为IoU,即人工标注的bbox和预测的bbox的相交部分与两者合并的部分的占比。 EDA(exploratory data analysis)The images (at least many of them) are slices of the same image, not separate frames taken at different times.data leak:The images in test are just shifted versions of images in train. The problem also happens in train, it looks like airbus had bigger images and then the 768x768 are random crops of the bigger images; but it looks they didn’t check whether there were any overlaps.How to find:Run nearest neighbors on all imagesFor each image take N closest neighbors and find where it overlapsCutting all the images 256x256 they can be found easier because they match almost exactly (except for compression artifacts). up to nowdue to data leak,large data set,few computation source and time limit,I decided to pause the competition.","categories":[{"name":"Kaggle","slug":"Kaggle","permalink":"http://aier02.com/categories/Kaggle/"}],"tags":[{"name":"segmentation","slug":"segmentation","permalink":"http://aier02.com/tags/segmentation/"}]},{"title":"Introduction to statistical learning method U1","slug":"statistic_1","date":"2018-08-27T16:58:59.803Z","updated":"2019-01-07T03:44:15.658Z","comments":true,"path":"2018/08/28/statistic_1/","link":"","permalink":"http://aier02.com/2018/08/28/statistic_1/","excerpt":"","text":"李航老师的《统计学习方法》基本已经过一遍了，感觉只是略懂皮毛，现为了加强知识点的认识和部分课后题的实现，有必要进行个人总结。 统计学习 定义statistical learning 是关于计算机基于数据构建构建统计模型并运用模型对数据进行预测和分析的一门学科，是概率论、统计学、信息论、计算理论、最优化理论和计算机科学等学科的交叉学科。 学习对象和目的从数据出发，提取数据的特征，抽象出数据的模型（概率统计模型），并对数据进行预测和分析 实现统计学习方法的一般步骤得到一个有限的训练数据集合确定包含所有可能的模型的假设空间，即学习的模型的集合确定模型选择的准则，即学习的策略实现求解最优模型的算法，即学习的算法通过学习方法选择最优的模型利用最优模型对新的数据进行预测或则分析简而言之：数据-&gt;假设空间-&gt;策略-&gt;算法-&gt;最优模型-&gt;预测分析 监督学习统计学习包括了监督学习，非监督学习，半监督学习和强化学习。 基本概念输入所有可能取值的集合称为输入空间，同理输出所有可能的取值集合称为输出空间，通常output space 远小于 input space；而特征空间则是所有特征向量所在的空间，特征向量用于表示一个输入实例，特征空间的每个维度对应一个特征，输入空间可以和特征空间相同，也可把输入空间映射到空间，模型实质是定义在特征空间上的（对特征向量进行学习）。X表示输入变量，Y表示输出变量，输入变量X中的第i个表示为xi=(xi(1),xi(2),...,xi(n))Tx_i=(x_i^{(1)},x_i^{(2)},...,x_i^{(n)})^Tx​i​​=(x​i​(1)​​,x​i​(2)​​,...,x​i​(n)​​)​T​​N个数据的训练数据集(labled)表示为T={(x1,y1),(x2,y2),...,(xN,yN)}T=\\{(x_1,y_1),(x_2,y_2),...,(x_N,y_N)\\}T={(x​1​​,y​1​​),(x​2​​,y​2​​),...,(x​N​​,y​N​​)}输入到输出的映射关系由模型进行表示，所有可能的由输入空间（特征空间）到输出空间的映射的集合组成了假设空间，学习的范围局限在假设空间中。 统计学习的三要素 模型统计学习首先考虑是学习什么样的模型，在监督学习中就是要学习的条件概率分布或者决策函数，由所有可能的模型构成的集合组成了假设空间F,通常是一个由参数决定的函数族.决策函数模型的集合表示为$$F={f|Y=f_\\theta(X),\\theta\\in R^n}$$条件概率模型的集合表示为$$F={f|P=P_\\theta(Y|X),\\theta\\in R^n}$$其中θ\\thetaθ取值于n维的欧氏空间，称为参数空间 策略有了假设空间，接着考虑按照什么样的准则学习最优的模型，称为策略。 损失函数和风险函数损失函数度量模型预测的好坏（预测的结果和标记的差距），风险函数度量平均意义下的模型预测的好坏（在具体某次预测可能出错的期望） 损失函数记作L(f(X),Y)&gt;=0,常见类型:0-1损失函数（0-1 loss fuction ）：L(f(X),Y)={1,Y≠f(X)0,Y=f(X)L(f(X),Y) = \\begin{cases} 1, &amp; Y \\neq f(X)\\\\ 0, &amp; Y = f(X) \\end{cases}L(f(X),Y)={​1,​0,​​​Y≠f(X)​Y=f(X)​​平方损失函数(quadratic loss function):L(f(X),Y)=(Y−f(X))2L(f(X),Y) =(Y-f(X))^2L(f(X),Y)=(Y−f(X))​2​​绝对损失函数(absolute loss fuction):L(f(X),Y)=∣(Y−f(X))∣L(f(X),Y) =|(Y-f(X))|L(f(X),Y)=∣(Y−f(X))∣ 经验风险和结构风险模型f(x)关于训练数据集的平均损失称为经验风险：Remp(f)=1N∑i=1NL(yi,f(xi))R_{emp}(f) =\\frac 1N\\sum_{i=1}^NL(y_i,f(x_i))R​emp​​(f)=​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​))结构风险简单而言就是经验风险加入了正则化项，正则化项用于表示模型复杂度，因此结构风险最小化是为了防止过拟合而提出的策略。Rsrm(f)=1N∑i=1NL(yi,f(xi))+λJ(x)R_{srm}(f) =\\frac 1N\\sum_{i=1}^NL(y_i,f(x_i))+\\lambda J(x)R​srm​​(f)=​N​​1​​​i=1​∑​N​​L(y​i​​,f(x​i​​))+λJ(x)其中$\\lambda $&gt;=0,用以权衡经验风险和模型复杂度 算法算法是指学习模型的具体方法，一般而言就是求解模型f中的参数以达到模型的最优化，故很多时候统计学习的算法到最后基本都是最优化问题。 模型评估和模型选择 训练误差训练误差是模型关于训练数据集的平均损失，即前面所说的经验风险；R_{exp}(f) =\\frac 1N\\sum_{i=1}^NL(y_i,f(x_i))​ 测试误差测试误差跟训练误差相似，只是前者是在测试数据集上的平均损失 过拟合和模型选择一味最求模型对于训练数据的预测能力，所求得的模型往往会比真实模型更加复杂，这种现象叫做过拟合（模型参数过多，训练误差很小，但测试误差较大或者泛化能力很差），而模型的选择就是为了避免过拟合并提高模型对于未知数据的预测能力。 正则化模型选择的典型方法是正则化，通过结构风险最小化实现，即在经验风险后加上一个正则化项，一般是模型复杂度的单调递增函数（比如L_2范数）正则化的作用是选择经验风险和模型复杂度同时较小的模型；问题是为什么需要简单的模型？一方面是过拟合的存在使得模型有可能过度关注训练数据集的“个性”，导致模型的泛化能力下降；另一个解释是根据奥卡姆剃刀原理，“如无必要，勿增实体”，即在所有可能选择的模型中，能够很好地解释数据并且十分简单的模型才是最优的（尽管这个要求有点自相矛盾，此时λ\\lambdaλ往往起到折中的作用）；从贝叶斯估计的角度而言，正则化项对应于模型的先验概率，复杂的模型先验概率小，简单的模型先验概率大。 交叉验证基本思想是重复地使用数据，对给定的数据进行划分，然后组合成训练集和测试集，反复进行训练、测试和模型的选择。 简单交叉验证随机把数据集划分为训练集和测试集两部分（训练集更大），改变不同的条件使得在相同的训练集上也能得到不同的模型，然后在测试集进行模型的测试和选择。 S折交叉验证随机地把数据集划分为S个互不相交的子数据集，利用S-1个子数据集作为训练数据集，剩下的一个做为测试集；将这一过程对可能的S中选择重复进行，从得到的S个模型中选择测试误差最小的模型。 留一交叉验证S=N时，用于数据缺乏的情况下，即每次只拿一个数据样本作为测试集，进行N次相同操作，从N个模型中选择最优者（平均测试误差最小）。 泛化能力generalization alibity指由学习方法得到的模型对于未知数据的预测能力，常用测试误差评价学习方法的泛化能力，仅记测试数据集是十分宝贵的，在学习模型的过程中不能使用，要在训练完成后才能用于测试，保证对于学得的模型而言，测试数据是“未知的”。对于泛化能力的分析往往通过研究泛化误差的概率上界进行，常具有以下性质：样本容量增加，泛化上界趋于0；假设空间容量越大，模型就越难学，泛化误差上界就越大。存在定理，对于二类分类问题，当假设空间是有限个函数的集合时F={f1,f2,f3…,fd},对任意一个函数f∈\\in∈F,至少以概率1-δ\\deltaδ,以下不等式成立：R(f)&lt;=R^(f)+ϵ(d,N,δ)R(f)&lt;=\\hat R(f)+\\epsilon (d,N,\\delta)R(f)&lt;=​R​^​​(f)+ϵ(d,N,δ)即泛化误差&lt;=训练误差+N的单调递减函数(右端即为泛化误差的上界)ϵ(d,N,δ)=12N(logd+log1δ)\\epsilon (d,N,\\delta)=\\sqrt {\\frac 1{2N}(logd+log\\frac 1\\delta)}ϵ(d,N,δ)=√​​2N​​1​​(logd+log​δ​​1​​)​​​可见泛化误差上界和训练误差、样本容量均正相关，和模型复杂度d负相关。 生成模型和判别模型 生成模型由生成方法学到的模型称为生成模型，生成方法由数据学习联合概率分布P(X,Y),然后求出条件概率分布P(Y|X)作为预测的模型，即：P(Y∣X)=P(X,Y)P(X)P(Y|X)=\\frac {P(X,Y)}{P(X)}P(Y∣X)=​P(X)​​P(X,Y)​​生成模型表示了给定输入X产生输出Y的生成关系，典型的生成模型由朴素贝叶斯法和隐马尔可夫模型。 判别模型由判别方法学到的模型称为判别模型，判别方法由数据直接学习决策函数f(X)或者条件概率P(Y|X)作为预测的模型。判别模型表示给定输入X应该预测什么样的输出Y。典型的判别模型有k紧邻法，感知机，决策树，逻辑斯谛回归模型，最大熵模型，支持向量机，提升方法，条件随机场等。存在隐变量时不能使用判别方法，但可以用生成方法；判别方法直接面对预测，准确率更高。","categories":[{"name":"statistical learning method","slug":"statistical-learning-method","permalink":"http://aier02.com/categories/statistical-learning-method/"}],"tags":[{"name":"basic knowledge","slug":"basic-knowledge","permalink":"http://aier02.com/tags/basic-knowledge/"},{"name":"introduction","slug":"introduction","permalink":"http://aier02.com/tags/introduction/"}]},{"title":"Build personal blog","slug":"blog_tutorial","date":"2018-08-07T11:24:35.583Z","updated":"2018-10-03T08:30:19.069Z","comments":true,"path":"2018/08/07/blog_tutorial/","link":"","permalink":"http://aier02.com/2018/08/07/blog_tutorial/","excerpt":"","text":"最近在加强ml和cv基础知识的学习，为了加深理解，同时记录自己的学习过程，尝试着写blog；向好友请教后得知建立个人blog的方式，我的选择是Hexo(一种静态博客网页框架)+Github page（免费托管博客项目代码），当然还有租云服务器和自己写后台和前端的方式，前者更加方便和易于上手。 前期准备 安装Git毕竟所有项目代码都是托管到Github上面，必须保证系统中已经安装了git，terminal中输入git不出现commant not found即可 安装Node.js因为Hexo的使用基于Node.js，所以要先安装Node.js和他的包安装器npm,建议到官网下载pkg并选择稳定版本(LTS) Github创建项目在Github上面创建一个名为：yourname.github.io 的空项目，yourname是指你创建的github账户名（github上面每个用户的用户名是唯一的标识），该Repository就是之后你的blog所有代码和文件存放的地方，blog的地址在不添加设置的情况下：https://yourname.github.io 安装Hexo在终端输入npm命令下载静态网页生成器Hexo1npm install -g hexo若出现permiss denied等情况，则加入sudo1sudo npm install -g hexo 创建Hexo文件夹在本地文件系统中创建Hexo文件夹，cd进入该文件夹，然后进行初始化1Hexo init没有错误，则以后所有操作都必须在该文件目录下进行，特别注意文件夹Hexo/node_models,所有通过npm install XXX --save操作下载的依赖都会存放在该文件夹中，易于包的管理(–save参数的意义就是存放在node_models)顺利完成上述步骤后可以登陆https://yourname.github.io 查看效果 绑定个人域名Ps:不想花钱的同学可以跳过 购买国外个人域名对于没有个人域名的同学来说，国内备案实在是太漫长了(我前段时间就在腾讯云备案过一次，周期太长==)，直接购买国外的域名方便而且预算基本一样，推荐namesilo，60一年，后缀多选择而且有免费的private protection；注册的时候我写的假的信息(除了邮箱）；一开始先检索你想注册的域名，然后在根据英文指导取购买就ok了(默认设置),网站支持alipay，非常方便了。 更改DNS统一使用一个dns的话对于以后多域名管会更加方便，推荐使用国内的厂商dnspod，登陆后添加你更注册的域名进行管理，主要添加连个主机记录，分别是@和www,譬如我的设置为图中A记录的记录值为github page中项目的ip，可以通过在终端中输入ping https://yourname.github.io 找到，也可在Github help中找到。登陆namesilo，在右侧找到domain manager,进入后选择更改nameserver,处理过程还是挺长的，所以不用急着登陆你的域名 更改blog主题在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件 选择主题进入官网选择适合的主题[hexo](https://hexo.io/themes/)，进入相应的Github地址，git clone命令把整个文件夹都下载下来，存放在Hexo/themes文件夹中。 更改配置文件一般而言，下载下来的主题文件中都有新手引导，注意readme就ok了。 部署项目代码在Hexo/_config.yml和themes里面的config文件中添加以下说明1234deploy: type: git repo: https://github.com/aier02/aier02.github.io.git branch: master注意修改repo的地址为你的github上面的地址(只要修改你的用户名)在Hexo目录下输入1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d即可将本地下的Hexo/public文件夹所有内容上传到github项目中(可能需要生成公私钥，请自行百度）hexo clean实质是删除Hexo/public，而hexo g则是根据配置和Hexo/source生成Hexo/public,新写的blog存放在Hexo/source/_posts即可，hexo d命令则是将Hexo/public上传到git服务器中,使用个人域名的同学还得在Github上面的yourname.github.io仓库根目录下新建一个CNAME文件，写入你的个人域名,不需要http和www,比如我的就是在第一行为：aier02.com 个人寄语blog关键在于内容，所以我基本很多操作都是为了方便，倘若遇到了什么问题可在下方评论提出(主要是看我是否也遇到了可以提供解决方案，没有踩过的坑我也不会=。=）,还有可以选择的theme很多，奉劝各位以实用为主，再好看的blog没有内容也是没价值的。","categories":[{"name":"blog","slug":"blog","permalink":"http://aier02.com/categories/blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://aier02.com/tags/Hexo/"},{"name":"Github page","slug":"Github-page","permalink":"http://aier02.com/tags/Github-page/"},{"name":"namesilo","slug":"namesilo","permalink":"http://aier02.com/tags/namesilo/"}]}]}